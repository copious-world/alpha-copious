<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

<!-- MANIFEST... -->
	<link rel="manifest" href="./manifest.json" />
<!-- ... -->

	<meta name="author" content="Richard Leddy" />
	<meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
	<meta id="theme-color" name="theme-color" content="#452770">

	<link rel="canonical" href="http://www.copious.world">
	<link rel="icon" type="image/svg+xml" href="./copiousLogo.svg" />

	<!-- metas for PWA -->
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="default">
	<meta name="apple-mobile-web-app-title" content="copious-world-container">
	<meta name="msapplication-TileImage" content="link to the image in static folder">
	<meta name="msapplication-TileColor" content="#000">

	<title>Copious World</title>
	<meta name="description" content="An entry point into the our world of AI, IoT, and Communities built around songs, etc.">
<style>
		/*csslint important:false*/

/* ==========================================================================
   Pure Base Extras
   ========================================================================== */

/**
 * Extra rules that Pure adds on top of Normalize.css

html {

}
*/

	/**
	* Always hide an element when it has the `hidden` HTML attribute.
	*/

	.hidden,
	[hidden] {
		display: none !important;
	}

	/**
	* Add this class to an image to make it fit within it's fluid parent wrapper while maintaining
	* aspect ratio.
	*/
	.pure-img {
		max-width: 100%;
		height: auto;
		display: block;
	}

	.items {
		display: flex;
		flex-wrap: wrap;
		margin-left: -10px;
		margin-top: -10px;
	}

	.items .item {
		flex: 1 0 300px;
		box-sizing: border-box;
		background: -webkit-linear-gradient(to right, rgba(242, 242, 210, 0.3), white);
		background: linear-gradient(to right, rgba(242, 242, 210, 0.3), white );
		color: #171e42;
		padding: 10px;
		margin-left: 10px;
		margin-top: 0px;
	}

	.items .extra-i {
		padding-left: 10%;
		padding-bottom: 4px;
		padding-right: 12px;
		font-size: 110%;
		font-family: sans-serif;
	}

	.middleBanner {
		text-align: 'center';
		padding-left: 10%;
		padding-right: 10%;
		font-weight:bold;
		color: darkgreen;
		padding-top:4%;
		overflow:auto;
	}

	.applink {
		padding:3px;
		background-color: cornsilk;
		width:inherit;
		min-height: 100%;
		color:darkolivegreen;
		font-weight: bolder;

	}

	.extraBanner {
		text-align: 'center';
		padding-left: 10%;
		padding-right: 10%;
		font-weight:bold;
		color: #FF4400;
		padding-top:4%;
	}


	.fillLowerWrap {
		width: 66%;
		margin-left:0px;
		margin-right:0px;
		padding: 8px;
		margin-top:8px;
		background: -webkit-linear-gradient(to right, white, #FAFAFF);
		background: linear-gradient(to right, white, #FAFAFF );
		margin-left: 10px;
	}

	.fitMenuLower {
		width: 95%;
		height: 50%;
		margin-left:0px;
		margin-right:0px;
		padding: 8px;
		margin-top:8px;
		background: -webkit-linear-gradient(to right, white, #FAFAFF);
		background: linear-gradient(to right, white, #FAFAFF );
		margin-left: 10px;
	}

	#squashMenu:hover {
		border: 1px solid rgb(230,230,240,0.4);
		padding-top:4px;
		background-color: #EFEFEF;
	}

	#squashMenuContainer {
		position:absolute;
		visibility:hidden;
		top : 0; left : 0;
		height:100%;
		width: 55%;
		z-index:100;
		border: rgba(252, 190, 190, 0.4) 2px solid;
		background-color: white;
	}

	.fade_able {
		position:absolute;
		visibility:hidden;
		top : 10px; left : 10px;
		height:80%;
		width: 40%;
		z-index:101;
		border: rgba(252, 190, 190, 0.4) 2px solid;
		background-color: white;
		overflow:hidden;
	}

	.solid_able {
		position:absolute;
		visibility:hidden;
		top : 10px; left : 10px;
		height:80%;
		width: 40%;
		z-index:111;
		border: rgba(252, 190, 190, 0.4) 2px solid;
		background-color: white;
		overflow: hidden;
	}

	@media screen and (max-width: 950px) {
		.solid_able {
			width: 90%;
		}
	}

	#thankyou_box {
		position:absolute;
		visibility:hidden;
		top : 25%; left : 25%;
		height:50%;
		width: 50%;
		z-index:150;
		border: rgba(100, 5, 5, 0.6) 2px solid;
		background-color: lightgoldenrodyellow;
		overflow: auto;
	}

	@media screen and (max-width: 1040px) {
		.fade_able {
			width: 60%;
		}
	}

	@media screen and (max-width: 600px) {
		.fade_able {
			width: 90%;
		}
	}

	.fade_able_content {
		height:100%;
		width: 100%;
		overflow:auto;
	}

	.togglebar {
		height:20px;
		visibility:inherit;
		background-color: navy;
		text-align:right;
	}

	.closer_x {
		padding:2px;
		color:purple;
		font-weight:bolder;
		border: solid 1px red;
		cursor:pointer;
	}

	@media (max-width: 1225px) {
		.fillLowerWrap {
			visibility : "none";
			height : 0px;
		}
	}


	.fillLower {
		border: darkred 2px solid;
		height: 96%;
		width: 96%;
		margin-left: 10px;
		padding:8px;
		background: -webkit-linear-gradient(to right, rgba(252, 252, 240, 0.4), #FEFEFE);
		background: linear-gradient(to right, rgba(252, 252, 240, 0.4), #FEFEFE );
	}

	button {
		cursor: pointer;
		font-size: 101%;
		font-weight: bold;
		color: darkblue;
		margin: 2px;
		width:120px;
	}

	button:hover {
		background-color : #CACAFF;
		color: darkred;
	}

	@media screen and (max-width: 390px) {
		.items .extra-i {
			padding-left: 1%;
		}
	}

	@media screen and (max-width: 600px) {
		.items .extra-i {
			padding-left: 3%;
		}
	}

	.longviz {
		visibility : "visibile";
		height: 10px;
		background-color:inherit;
	}

	@media (max-width: 1040px) {
		.longviz {
			visibility : "none";
			height : 0px;
		}
	}

	.shortviz {
		visibility : "none";
		height:0px;
		margin-top:6px;
	}

	@media (max-width: 620px) {
		.shortviz {
			visibility : "visible";
			height:2px;
			background-color:darkgreen;
			margin-bottom:12px;
		}
	}

	@media (min-width: 1040px) {
		.shortviz {
			visibility : "visible";
			height:120px;
			border: 2px darkblue solid;
			background-color:#FFFFF6;
			margin-bottom:30px;
			margin-top:5px;
		}
	}

	@media (min-width: 380px) {
		.items .item {
			max-width: calc(100% - 20px);
		}
		.items .extra-i {
			padding-left: 3%;
		}
	}
	@media (min-width: 410px) {
		.items .item {
			max-width: calc(100% - 10px);
		}
	}
	@media (min-width: 620px) {
		.items .item {
			max-width: calc(50% - 10px);
		}
	}
	@media (min-width: 830px) {
		.items .item {
			max-width: calc(50% - 10px);
		}
	}
	@media (min-width: 1040px) {
		.items .item {
			max-width: calc(33.33333% - 10px);
		}
	}
	@media (min-width: 1250px) {
		.items .item {
			max-width: calc(25%- 10px);
		}
	}
	@media (min-width: 1460px) {
		.items .item {
			max-width: calc(20% - 10px);
		}
	}
	@media (min-width: 1670px) {
		.items .item {
			min-width: calc(16.66667% - 10px);
		}
	}


	body {
		border: 1px solid black;
		
		-moz-box-sizing: border-box;
		box-sizing: border-box;
	}


	@media screen and (orientation: portrait) {
		#mainNav {
			width: 100%;
		}
	}

	@media screen and (orientation: landscape) {
		#mainNav {
			width: 100%;
		}
	}

	main {
		border-left: solid 3px navy;
		border-top: solid 1px #8833BB;
		padding : 1px;
		height: calc(100vh - 90px);
		background: -webkit-linear-gradient(to left, rgba(252,252,255,0.5), #f6f5ef );
		background: linear-gradient(to left, rgba(252,252,255,0.5), #f6f5ef  );
	}

	iframe {
		border: solid 3px rgb(155, 155, 178);
		padding: 2px;
		height : 100%;
		width: 100%;
	}

	#mainNav {
		font-family: 'Montserrat', 'Helvetica Neue', Helvetica, Arial, sans-serif;
		font-weight: 700;
		text-transform: uppercase;
		background: blue;
		border-left: solid 3px navy;
		border-top: solid 3px navy;
		border-bottom: solid 3px rgba(252,252,255,0.7);
		min-height: 90px;
		padding: 20px;
		background: -webkit-linear-gradient(to left, rgba(242, 242, 210, 0.3), white);
		background: linear-gradient(to left, rgba(242, 242, 210, 0.3), white );
		
	}

	#mainNav table {
		padding-left: 3%;
	}


	#mainNav  table  a:focus { outline: none; }
	#mainNav  table  .navbar-brand {
		font-size: 1.1rem;
		color: white;
	}

	#mainNav  table  .navbar-brand.active, #mainNav .navbar-brand:active, #mainNav .navbar-brand:focus, #mainNav .navbar-brand:hover {
		color: white;
	}

	#mainNav  table  .navbar-nav {
		letter-spacing: 1px; }

	#mainNav  table  .navbar-nav li.nav-item {
		display:inline;
	}

	
	
	#mainNav  table  .navbar-nav li.nav-item a.nav-link {
		color: darkgreen;
		text-decoration: none;
		vertical-align: top;
		padding-right: 10px;
	}

	#mainNav  table  .navbar-nav li.nav-item a.nav-link:hover {
		color: #18BC9C;
		outline: none;
		
	}


	#mainNav  table  .navbar-nav a.nav-text {
		background-color : rgba(242,222,255,0.6);
		border-radius: 25px;
		margin-bottom: 9px;
		margin-right: 6px;
		white-space: nowrap;
	}


	#mainNav  table  .navbar-nav li.nav-item a.nav-link:active, #mainNav .navbar-nav li.nav-item a.nav-link:focus { color: white; }
	
	.footer-list li {
		list-style-type: none;
	}

	.footer-list li a:hover { color: gold; }
	

	.fit-link {
		color:rgb(5, 34, 5);
		font-size: 0.85em;
		text-align: center;
		margin-left: 8px;
	}


	.hover_group {
		cursor:pointer;
	}

	.hover_group rect {
		fill:#e6e6e6;
	}

	.hover_group:hover rect {
		fill: #F6F6e6;
	}


	@media (min-device-width: 480px) and (orientation: portrait) {

		footer {
			padding:10px;
			background: -webkit-linear-gradient(to left, rgba(252,252,255,0.5), #fffbe2 );
			background: linear-gradient(to left, rgba(252,252,255,0.5), #fffbe2  );
			text-align: center;
			font-size: 0.85em;
		}
	
		footer a {
			text-decoration:none;
			color:darkgreen;
			font-weight:bold;
			font-style: italic;
		}

		.fit-link {
			color:rgb(5, 34, 5);
			font-size: 0.85em;
			text-align: center;
		}

	}
	/* ----------- iPhone ----------- */

	@media only screen 
		and (min-device-width: 320px) 
		and (max-device-width: 480px)
		and (-webkit-min-device-pixel-ratio: 2) {

		footer {
			padding:4px;
			background: -webkit-linear-gradient(to left, rgba(252,252,255,0.5), #fffbe2 );
			background: linear-gradient(to left, rgba(252,252,255,0.5), #fffbe2  );
			text-align: center;
			font-size: 0.65em;
			
		}

		footer a {
			text-decoration:none;
			color:darkgreen;
			font-weight:bold;
			font-style: italic;
			font-size: 0.65em;
		}

		.fit-link {
			color:rgb(5, 34, 5);
			font-size: 0.65em;
			text-align: center;
			margin-left: 8px;
		}

	}


	/* ----------- Galaxy S3 ----------- */

	/* Portrait and Landscape */
	@media screen 
		and (device-width: 360px) 
		and (device-height: 640px) 
		and (-webkit-device-pixel-ratio: 2) {

		footer {
			padding:4px;
			background: -webkit-linear-gradient(to left, rgba(252,252,255,0.5), #fffbe2 );
			background: linear-gradient(to left, rgba(252,252,255,0.5), #fffbe2  );
			text-align: center;
			font-size: 0.65em;
			
		}

		footer a {
			text-decoration:none;
			color:darkgreen;
			font-weight:bold;
			font-style: italic;
			font-size: 0.65em;
		}

		.fit-link {
			color:rgb(5, 34, 5);
			font-size: 0.65em;
			text-align: center;
			margin-left: 4px;
		}

	}


	/*  Landscape */
	@media screen and (orientation: landscape)
		and (device-width: 360px) 
		and (device-height: 640px) 
		and (-webkit-device-pixel-ratio: 2) {

		footer {
			padding:4px;
			background: -webkit-linear-gradient(to left, rgba(252,252,255,0.5), #fffbe2 );
			background: linear-gradient(to left, rgba(252,252,255,0.5), #fffbe2  );
			text-align: left;
			font-size: 0.55em;
			
		}

		footer a {
			text-decoration:none;
			color:rgb(18, 60, 18);
			font-weight:bold;
			font-style: italic;
			font-size: 0.55em;
		}


		.footer-list li {
			list-style-type: none;
		}

		.footer-list li a:hover { color: gold; }


		.fit-link {
			color:rgb(5, 34, 5);
			font-size: 0.55em;
			text-align: center;
			margin-left: 4px;
		}


	}



	/* ----------- Galaxy S4, S5 and Note 3 ----------- */

	/* Portrait and Landscape */
	@media screen 
		and (device-width: 320px) 
		and (device-height: 640px) 
		and (-webkit-device-pixel-ratio: 3) {

		footer {
			padding:4px;
			background: -webkit-linear-gradient(to left, rgba(252,252,255,0.5), #fbf4c2 );
			background: linear-gradient(to left, rgba(252,252,255,0.5), #fbf4c2  );
			text-align: center;
			font-size: 0.62em;
			
		}

		footer a {
			text-decoration:none;
			color:darkgreen;
			font-weight:bold;
			font-style: italic;
			font-size: 0.62em;
		}

		.fit-link {
			color:rgb(5, 34, 5);
			font-size: 0.55em;
			text-align: center;
			margin-left: 4px;
		}

	}
	
	/* Landscape */
	@media screen  and (orientation: landscape)
		and (device-width: 320px) 
		and (device-height: 640px) 
		and (-webkit-device-pixel-ratio: 3) {

		footer {
			padding:4px;
			background: -webkit-linear-gradient(to left, rgba(252,252,255,0.5), #fbf4c2 );
			background: linear-gradient(to left, rgba(252,252,255,0.5), #fbf4c2  );
			text-align: left;
			font-size: 0.55em;
			text-decoration:none;				
		}

		footer a {
			text-decoration:none;
			color:rgb(28, 92, 28);
			font-weight:bolder;
			font-style: italic;
			font-size: 0.55em;
		}


		.fit-link {
			color:rgb(5, 34, 5);
			font-size: 0.55em;
			text-align: center;
			margin-left: 4px;
		}

	}

	.copiouslink:hover {
		fill:navy;
	}
	.copiouslink {
		fill:black;
	}

	* {margin: 0; padding: 0; box-sizing: border-box}
	
	.PhIOtjDr_0 {
		fill:none;
		stroke:#1c1448;
		stroke-width:4.59875107;
		stroke-miterlimit:4;
		stroke-dasharray: 2948 2950;
		stroke-dashoffset: 2949;
		animation: PhIOtjDr_draw 6666ms ease-in forwards;
	}

	@keyframes PhIOtjDr_draw {
		100% {stroke-dashoffset: 0}
	}

	@keyframes PhIOtjDr_fade {
		0% {stroke-opacity: 1}
		97.1830985915493% {stroke-opacity: 1}
		100% {stroke-opacity: 0}
	}

	.form_el {
		border:lightgray solid 1px;
		padding:6px;
		margin:2px;
		width:80%;
	}

	.form_el_inner {
		border:lightgray solid 1px;
		padding:6px;
		margin:2px;
		width:100%;
	}

	label {
		font-weight:bold;
		color:darkgreen;
		width:35%;
	}

	.field_el {
		width:65%;
	}

	@media (max-width: 1040px) {
		.field_el {
			width:94%;
			margin-left:3%;
			margin-right:3%;
		}
	}

	#contact_box {
		background: -webkit-linear-gradient(to right, rgba(252, 252, 240, 1.0), #FEFEFE);
		background: linear-gradient(to right, rgba(252, 252, 240, 1.0), #FEFEFE );
	}

	.textarea_field_el {
		width: 94%;
		margin:3%;
	}

	.error-message {
		visibility:hidden;
		width:75%;
		font-weight:bolder;
		color:red;
		background-color:white;
		border: solid 1px orange;
		padding:2px;
		margin:3px;
	}

	/* The Modal (background) */
	.modal {
		display: none; /* Hidden by default */
		position: relative; /* Stay in place */
		z-index: 1; /* Sit on top */
		left: 0;
		top: 0;
		width: 100%; /* Full width */
		height: 100%; /* Full height */
		overflow: auto; /* Enable scroll if needed */
		background-color: rgb(0,0,0); /* Fallback color */
		background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
		-webkit-animation-name: fadeIn; /* Fade in the background */
		-webkit-animation-duration: 0.4s;
		animation-name: fadeIn;
		animation-duration: 0.4s
	}

	/* Modal Content */
	.modal-content {
		position: inherit;
		top: 0;
		background-color: #fefefe;
		width: 100%;
		-webkit-animation-name: slideIn;
		-webkit-animation-duration: 0.4s;
		animation-name: slideIn;
		animation-duration: 0.4s
	}

	/* The Close Button */
	.close {
		color: white;
		float: right;
		font-size: 18px;
		font-weight: bold;
	}

	.close:hover,
	.close:focus {
		color: #000;
		text-decoration: none;
		cursor: pointer;
	}

	.modal-header {
		padding: 2px 16px;
		background-color: #4ca85c;
		color: white;
	}

	.modal-body {padding: 2px 16px;}

	.modal-footer {
		padding: 2px 16px;
		margin-bottom: 20px;
		background-color: darkgreen;
		color: white;
	}

	/* Add Animation */
	@-webkit-keyframes slideIn {
		from {bottom: -300px; opacity: 0}
		to {bottom: 0; opacity: 1}
	}

	@keyframes slideIn {
		from {bottom: -300px; opacity: 0}
		to {top: 0; opacity: 1}
	}

	@-webkit-keyframes fadeIn {
		from {opacity: 0}
		to {opacity: 1}
	}

	@keyframes fadeIn {
		from {opacity: 0}
		to {opacity: 1}
	}

	#logout-control-top {
		visibility: hidden;
		display: none;
	}

</style>
</head>
<script>
	var g_siteURL = window.location.host;
	var g_finalizers = []
	var g_loginStateViewHolders = {}
</script>
<body>
	<nav id="mainNav">
		<table style="width:100%">
			<tr>
				<td style="width:62;height:63">
					<a class="nav-link" href="/">
						<svg version="1.0" width="36" height="36" viewBox="0 0 250 250" preserveAspectRatio="xMidYMid meet" id="logo" >
							<defs id="defs10"/>
							<path class="PhIOtjDr_0"  id="path6" d="m 30.107062,7.4672872 c 4.67725,2.6985208 8.37554,8.6930958 12.94402,20.5087688 7.17904,19.072767 24.58277,67.337762 29.69511,82.950634 l 5.32989,15.9502 -13.70543,-0.25058 -10.468161,2.57106 -8.132079,2.99946 -4.78602,5.90784 0.76141,-6.91979 c 0.65264,-6.50536 0.32632,-7.85462 -5.43866,-25.31791 C 27.822822,80.549048 20.535012,60.127019 12.703332,40.215781 5.4155222,21.730904 4.4365622,15.57249 7.8085322,10.503124 11.941922,4.43145 22.384152,2.9954505 30.107062,7.4672872 Z M 238.08162,22.742849 c 3.69828,2.110631 6.52639,6.669206 6.52639,10.379672 0,1.686578 -2.93688,12.740881 -6.63517,24.469814 -19.68797,64.138095 -30.34775,107.931245 -30.34775,124.806655 0,4.6453 -1.08775,7.68113 -18.60024,50.80931 l -4.35093,10.79409 -67.76577,0 -67.765758,0 -14.35808,-35.35063 -14.35808,-35.3603 17.62128,-20.75934 17.5125,-20.75935 29.36879,0 c 32.631998,0 5.455822,5.28877 29.390108,7.16797 -3.81133,6.98972 7.16732,11.29772 7.16732,11.29772 l 2.51778,3.43975 c -1.74038,3.20932 -4.92039,6.69891 -9.3801,9.5709 l -3.2632,2.11064 -9.78959,-2.62144 c -8.593088,-2.27446 -11.312428,-2.61179 -22.080978,-2.61179 -13.0528,-0.0964 -14.35808,0.2506 -14.35808,4.29837 0,2.70817 3.15443,3.63336 12.72648,3.63336 21.42834,0 38.723308,8.01847 47.533928,22.10863 3.58951,5.73436 7.17904,15.86345 7.17904,20.50876 0,2.86236 4.45971,5.05973 7.50536,3.79721 2.82811,-1.09868 2.93687,-4.64531 0.65264,-14.01306 -2.28424,-9.36772 -7.83169,-17.88734 -15.77214,-24.29632 -5.32988,-4.30799 -6.30884,-5.49342 -5.11233,-6.24517 1.19649,-0.76135 2.06669,-0.51077 4.0246,1.08906 6.30885,5.23321 19.03534,7.00654 27.73719,3.88395 5.87377,-2.11064 11.85631,-7.17036 15.11951,-12.74088 1.52281,-2.53468 5.98253,-16.03694 9.89835,-29.9536 10.98611,-38.396111 22.08098,-72.320389 30.13021,-92.665317 5.54744,-14.176879 12.40016,-19.737762 23.16871,-18.812555 2.93688,0.250577 6.63517,1.175785 8.15801,2.023891 z m -126.72091,50.03831 c 2.28424,0.510792 5.76499,2.11063 7.72291,3.633367 5.87375,4.558576 6.20008,7.257098 3.80705,29.278954 -1.1965,10.71701 -1.94404,26.93071 -2.27035,27.1042 -0.32632,0.25057 -8.38942,-6.50868 -17.41761,-6.25812 l -16.533538,0.42407 0.65264,-6.66922 c 0.32632,-3.62372 1.19651,-13.83956 1.84915,-22.619385 0.65264,-9.19425 1.74037,-17.125977 2.50179,-18.561977 3.2632,-5.907835 10.550998,-8.269041 19.687958,-6.331889 z m 48.5129,9.454465 c 2.06668,1.011946 4.56848,3.209314 5.54744,4.89589 1.84914,2.871998 1.84914,4.22126 -0.8702,33.750816 -1.52282,17.04886 -3.37196,32.575 -4.24216,35.02295 -3.15442,8.51961 -9.13695,13.07819 -18.16513,13.67573 -4.78601,0.25056 -6.41762,0 -9.46327,-1.69622 -5.87376,-3.12256 -6.41764,-4.29838 -2.93689,-7.42094 6.20008,-5.744 4.00097,-11.09854 1.92352,-15.89687 0,0 -0.33391,-1.79223 -2.65798,-4.24016 l -2.01123,-1.92782 3.94219,-26.79768 c 1.95792,-22.869967 2.17547,-23.795174 5.11237,-26.667174 4.89478,-4.89589 16.96861,-6.24515 23.82134,-2.698522 z" />
							<rect style="fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:4.80000019;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" id="rect4169" width="68.005806" height="55.413109" x="62.964886" y="157.3824"/>
							<rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:1.60000002;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" id="rect4170" width="39.957146" height="46.691494" x="105.05587" y="172.33051"/>
							<rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" id="rect4172" width="134.35677" height="7.9790406" x="49.16119" y="238.93228"/>
							<text xml:space="preserve" style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:184.28874207px;line-height:125%;font-family:'Arial Rounded MT Bold';-inkscape-font-specification:'Arial Rounded MT Bold, Normal';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#0000ff;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" x="6.6644416" y="260.41125" id="text4161" transform="scale(1.041834,0.95984582)"><tspan id="tspan4163" x="6.6644416" y="260.41125">C</tspan></text>
							<text xml:space="preserve" style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:28.53204727px;line-height:125%;font-family:sans-serif;-inkscape-font-specification:'sans-serif, Bold';text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#ff0000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" x="90" y="175.07523" id="text4165" transform="scale(0.90874022,1.1004245)"><tspan id="tspan4167" x="90" y="175.07523">opious</tspan></text>
						</svg>
					</a>
				</td>
				<td>
                    &nbsp;
				</td>
				<td>
					<!-- Lifecycle&nbsp; <span id="lifecycle-report">&nbsp;</span> -->
					Copious World
				</td>
			</tr>
		</table>
	</nav>
	<main id="app-sourcing">
	<iframe src="./new_user.html" id="app-human-frame">

	</iframe>
	</main>
<footer>
	<ul class="footer-list">
		<li>
			<a class="fit-link" href="http://www.copious.world" style="text-decoration: none;">copyright &copy; 2024 copious.world</a>
		</li>
	</ul>
</footer>


</body>
</html>
<script>


	// SERVICE WORKER
	
	function postDataFromThePage() {}  // TBD


	const LOGIN_URL = `https://cloud.copious.world/login`
	const APPLICATION_URL = `https://cloud.copious.world/pwa/market-place/`

	if ( !('serviceWorker' in navigator) ) {
		let main_contaier = document.getElementById("app-sourcing")
		main_contaier.innerHTML = "Sorry... this browser does not support progressive web applications"
	} else {

		const HUMAN_PAGE_UPDATE = 'human-page-update'

		async function service_worker_message_handler(msg_event) {
			let data = event.data
			let origin = event.origin
			let id = event.lastEventId
			let sourceObj = event.source // ... the actual object to which a message may be sent...
			let ports = event.ports  // list of MessagePort objects
			// what to do
		}


		async function service_worker_error_handler(msg_event) {
			let data = event.data
			let origin = event.origin
			let id = event.lastEventId
			let sourceObj = event.source // ... the actual object to which a message may be sent...
			let ports = event.ports  // list of MessagePort objects
			// what to do
			console.error("Receive message from service worker failed!");
		}

		// ---- ---- ---- ---- ---- ---- ----
		//
		function logState(state) {
			console.log(state)
		}

		//
		navigator.serviceWorker.onmessage = (m_evnt) => {
			service_worker_message_handler(m_evnt)
		}

		navigator.serviceWorker.onmessageerror = (em_evnt) => {
			service_worker_error_handler(em_evnt)
		};

		// navigator.serviceWorker.startMessages();  done when setting up the handler


		// Events from the serive worker
		navigator.serviceWorker.oncontrollerchange = () => {
			console.log('This page is now controlled by:', navigator.serviceWorker.controller);
			var msg = {
				'human-page-update': true
			}
			navigator.serviceWorker.controller.postMessage(msg)
		};


		// ---- ---- ---- ---- ---- ---- ----
		//
		async function init_service_worker() {
			try {
				//
				//
				let options = {
					scope : "./",
					type : "classic",
					updateViaCache : "all"
				}
				// The service worker gets fetched from the HTTPS server
				let registration = await navigator.serviceWorker.register('./service-worker.js',options)
				console.log('Service Worker is registered!')
				// now the lifecycle begins ver a new version
				registration.onupdatefound = (ev) => {    // what to do if the server has a new version
					//
					let serviceWorker;
					if ( registration.installing ) {
						// the service worker has been fetched from the server during registration
						// now get stuff that goes into cache... this tell the client about it
						serviceWorker = registration.installing;
						//document.getElementById("lifecycle-report").textContent = "installing";
					} else if ( registration.waiting ) {
						// waiting for clients to quit using the old version (installed and activating)
						// clear out the old caches any final setup processes
						document.querySelector("#kind").textContent = "waiting";
						//document.getElementById("lifecycle-report").textContent = "waiting";
					} else if ( registration.active ) {
						// finally active -- new clients can interact with the service worker (messages and events)
						serviceWorker = registration.active;
						//document.getElementById("lifecycle-report").textContent = "active";
					}
					//
					logState(serviceWorker.state);
					serviceWorker.onstatechange = (evn) => {
						logState(evn.target.state); 
						// one of 
						// "parsed",
						// "installing"
						// "installed"
						// "activating"
						// "activated"
						// "redundant"
					}
					//
				}
			} catch (e) {
				console.log("failed to register service sworker")
				console.log(e)
			}
			//
		}

		async function ready_service_worker() {
			//
			try {
				let registration = await navigator.serviceWorker.ready
				if ( registration.sync ) {
					let tags = await registration.sync.getTags()
					const contained_page = HUMAN_PAGE_UPDATE
					if ( !(tags.includes(contained_page)) ) {
						await registration.sync.register(contained_page)
					}
				} else {
					postDataFromThePage();
				}
			} catch (e) {
				postDataFromThePage(e);
			}
			//
		}


		window.onload = async (evn) => {
			await init_service_worker()
			await ready_service_worker()
		}

	}



	//
	window.addEventListener('online', () => {
							if ( navigator.serviceWorker.controller ) {
								var msg = {
									'sendSongs': true
								}
								navigator.serviceWorker.controller.postMessage(msg)  // <--- This line right here sends our data to sw.js
							}
						});
	//
	window.addEventListener('offline', () => {
							//alert('You have lost internet access!');
						});


	// END OF SERVICE WORKER


// ---->>>
// MODULE: ONE TABLE(windowized)

// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

//>>  AppDBWrapper


// In the following line, you should include the prefixes of implementations you want to test.
window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
// DON'T use "var indexedDB = ..." if you're not in a function.
// Moreover, you may need references to some window.IDB* objects:
window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction || {READ_WRITE: "readwrite"}; // This line should only be needed if it is needed to support the object's constants for older browsers
window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;
// (Mozilla has never prefixed these objects, so we don't need window.mozIDB*)


/*

// autoIncrement set to true  (for this special case DB use )

DB_VERSION
DATA_STORE
describe_data

*/


function warn(str) {
    //
}


// a session is a project...
// a session object (sessionObject) is stored in the DB and may contain parts of data
// part_id identifies a part of the data (e.g. a layer or a component)

class AppDBWrapper {

    constructor(name,conf) {
        this._can_process_db = true
        if ( !(window.indexedDB) ) {
            this._can_process_db = false
            console.log("Your browser doesn't support a stable version of IndexedDB. Such and such feature will not be available.");
        }
        //
        let self = this
        // DATA_STORE
        // DB_VERSION
        // describe_data
        if ( conf ) {
            for ( let ky in conf ) {
                self[ky] = conf[ky]
            }    
        }
        //
        this.db = false
        this.current_session_name = 'none'
        this._session_name_list = []
        this.name = name
        //
    }


    set session_name(name) {
        this.current_session_name = name
    }

    get session_name() {
        return this.current_session_name
    }

    get name_list() {
        return this._session_name_list
    }

    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    init_database() {
        //
        if ( !(this._can_process_db) ) return false
        let self = this
        let db_name = this.name
        //
        let p = new Promise((resolve,reject) => {

            let request = window.indexedDB.open(db_name, this.DB_VERSION);
            //
            // <-- onerror
            request.onerror = (event) => {
                alert(`This web app will not store ${this.describe_data} without the use of computer storage.`)
            };
            
            // <-- onsuccess
            request.onsuccess = (event) => {
                //
                let db = event.target.result;
                db.onerror = (event) => {
                    console.log("Database error: " + event.target.error);
                    reject(event.target.error)
                };
                //
                self.db = db;
                resolve(db)
            }

            // <-- onupgradeneeded
            request.onupgradeneeded = (event) => {
                //
                let db = event.target.result;
                //
                if ( this.DATA_STORE !== undefined ) {
                    try {
                        let sessionObjectStore = db.createObjectStore(this.DATA_STORE, { autoIncrement : true });
                        sessionObjectStore.createIndex("name", "name", { unique: true });
                        sessionObjectStore.createIndex("sess_date_time", "sess_date_time", { unique: true });
                    } catch (e) {
                    }
                }
                if ( this.COMPLETION_STORE !== undefined ) {
                    try {
                        let completeStore = db.createObjectStore(this.COMPLETION_STORE, { autoIncrement : false, keyPath: 'name' });
                        completeStore.createIndex("name", "name", { unique: true });
                    } catch (e) {
                    }
                }

            //
            };
        })  // end of promise
        //
        return p
    }


    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    //      load_name_list
    // -- 
    load_name_list() {
        if ( !(this.db) ) return
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readonly");
        let dataStore = transaction ? transaction.objectStore(this.DATA_STORE) : false
        //
        if ( !(dataStore) ) return false
        let p = new Promise((resolve,reject) => {
            this._session_name_list = []
            let myIndex = dataStore.index('name');
            myIndex.openCursor().onsuccess = (event) => {
                let cursor = event.target.result;
                if ( cursor ) {
                    this._session_name_list.push(cursor.value.name)
                    this.application_total_entry(cursor.value)
                    cursor.continue();
                } else {
                    this.application_update_session_name_selections(this.current_session_name,this._session_name_list)
                    resolve(true)
                }
            }
        })
        //
        return p
    }

    // _apply_find_by_name
    //  -- a generic that calls success_callback when an element matches the index, or not_found_callback otherwise.
    //
    _apply_find_by_name(sess_name, store, success_callback, not_found_callback) {
        let nameIndex = store.index('name');
        nameIndex.get(sess_name).onsuccess = (evt) => {
            let value = evt.target.result;
            if ( value ) {
                if ( success_callback ) success_callback(value,nameIndex);
            } else {
                if ( not_found_callback ) not_found_callback();
            }
        };
    }

    // _add_session_to_db
    //  -- adds the session object to the db, sets up the basic fields... 
    //
    _add_session_to_db(dataStore,application_op,part_id) {
        //
        let sessionObj = {
            'name' : this.current_session_name,
            'sess_date_time' : '' + Date.now(),
            'data' : { },
            'hashes' : { },
            'edit_order' : []
        }
        //
        if ( part_id ) sessionObj.edit_order.push(part_id)
        //
        if ( (application_op !== undefined) && (typeof application_op === 'function') ) {
            application_op(sessionObj)
        }
        let request = dataStore.add(sessionObj);  // returning an async object to which handlers may be added
        return request
    }

    add_empty_session(name,application_op) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: remove_audio_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //
        this.current_session_name = name
        if ( application_op !== undefined ) {
            this._add_session_to_db(dataStore,application_op)
        } else {
            this._add_session_to_db(dataStore)
        }
    }

    //  update_session: 
    //      Parameters: sess_name -- A session or separate project or publication...
    //                  field --- the field to change (top level)
    //                  value --- set the field to this value
    //  returns: true if the session is available for update
    update_session(sess_name,field,value) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: get_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //
        let p = new Promise((resolve,reject) => {
          //
          // get_elem_callback
          let update_elem_callback = (value,dbIndex) => {          // element.name == sess_name exists
            //
            let keyRangeValue = IDBKeyRange.only(value.name);
            //
            dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
              let cursor = event.target.result;
              if ( cursor ) {
                //
                let sessionObj = cursor.value
                sessionObj[field] = value
                const request = cursor.update(sessionObj);
                request.onsuccess = async () => {
                    resolve(true)
                };

                request.onerror = (event) => {
                    resolve(false)
                }
              } else {
                resolve(false)
              }
            }
          }
          //
          // not_found_callback
          let not_found_callback = () => {                       // element.name == sess_name  NOT FOUND
            resolve(false)
          }
          //
          this._apply_find_by_name(sess_name, dataStore, update_elem_callback, not_found_callback)
        })
        //
        return p
    }


    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    // add_data -- 
    //  Parameters: blob_data -- data stored as part of the session
    //              session id could be a layer....
    add_data(blob_data,part_id) {
        if ( !(this._can_process_db) ) return false
        if ( !(this.db) ) {
          console.log(`db not initialized :: AppDBWrapper.add_data`)
          return;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false

        let p = new Promise((resolve,reject) => {
            let self = this
            // update_list_callback
            let update_list_callback = (value,dbIndex) => {     // if found update
                if ( !dbIndex || (typeof value === "undefined") ) {
                    resolve(false)
                    return;
                }
                let keyRangeValue = IDBKeyRange.only(value.name);
                dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                    let cursor = event.target.result;
                    if ( cursor ) {
                        // existing session 
                        let sessionObj = cursor.value
                        //
                        let blob_url = (typeof blob_data === 'string') ? blob_data : URL.createObjectURL(blob_data);
                        // map_id = part_id
                        // store revised data
                        sessionObj.data[part_id] = blob_data
                        // make sure the structure has been set up if not already
                        if ( sessionObj.hashes[part_id] === undefined ) {
                            sessionObj.hashes[part_id] = {}
                        }
                        if ( sessionObj.hashes[part_id].op_history === undefined ) {
                            sessionObj.hashes[part_id].op_history = []
                        }
                        // record the order in which sessions (layers) have been edited
                        sessionObj.edit_order.push(part_id)
                        //
                        // update IndexedDB
                        const request = cursor.update(sessionObj);
                        request.onsuccess = async () => {
                            try {
                                self.application_data_update(blob_url,part_id,blob_data,part_id)  // application handling of data e.g visual rep
                            } catch (e) {
                                console.log(e)
                            } finally {
                                resolve(true)
                            }
                        };

                        request.onerror = (event) => {
                            resolve(false)
                        }
                        //
                    } else {
                        resolve(false)
                    }
                }
            }
            // add_new_callback
            let add_new_callback = () => {          // if not found add a new one
                //
                let blob_url = (typeof blob_data === 'string') ? blob_data : URL.createObjectURL(blob_data);
                //
                let application_op = (sessionObj) => {
                    //
                    sessionObj.data[part_id] = blob_data
                    if ( sessionObj.hashes[part_id] === undefined ) {
                        sessionObj.hashes[part_id] = {}
                    }
                    sessionObj.hashes[part_id].op_history = []
                    //
                } 
                //
                let request = self._add_session_to_db(dataStore,application_op,part_id)
                if ( request ) {
                    request.onsuccess = (event) => {
                        self.application_data_update(blob_url,part_id,blob_data)  // application handling of data e.g visual rep
                        resolve(true)
                    };
                    request.onerror = (event) => {
                        resolve(false)
                    }
                }
                //
            }
            //
            this._apply_find_by_name(this.current_session_name, dataStore, update_list_callback, add_new_callback)    
        })
        //
        return p
    }


    // update_data

    update_data(blob_data,part_id,op_parameters) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
            console.log("db not initialized :: remove_audio_data")
            return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false

        let update_list_elem_callback = (value,dbIndex) => {
            let keyRangeValue = IDBKeyRange.only(value.name);
            dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                var cursor = event.target.result;
                if ( cursor ) {
                    let sessionObj = cursor.value
                    if ( sessionObj.data[part_id] != null ) {
                        let blob_url = URL.createObjectURL(blob_data);
                        sessionObj.data[part_id] = blob_data
                        // handle a case which should not happen
                        if ( sessionObj.hashes[part_id] === undefined ) {
                            sessionObj.hashes[part_id] = { 'op_history' : [] }
                        }
                        // update hash ops
                        let operation = this.app_pre_update_action(blob_data,part_id,op_parameters)
                        if ( !operation ) {
                            operation = {'op' : 'backup'}
                        }
                        sessionObj.hashes[part_id].op_history.push(operation)
                        //
                        const request = cursor.update(sessionObj);
                        request.onsuccess = async () => {
                            this.app_post_update_action(blob_data,part_id,blob_url)
                        };
                    }
                    //
                }
            }
        }

        let not_found_callback = () => {
            warn(`The session ${sess_name} is not in the database`)
        }

        //
        this._apply_find_by_name(this.current_session_name, dataStore, update_list_elem_callback, not_found_callback)    
    }


    // update_data_ops

    update_data_ops(part_id,pre_update,post_update) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
            console.log("db not initialized :: remove_audio_data")
            return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //
        let p = new Promise((resolve,reject) => {
            let self = this

            let add_elem_original_chunks_callback = (value,dbIndex) => {
                let keyRangeValue = IDBKeyRange.only(value.name);
                    dbIndex.openCursor(keyRangeValue).onsuccess = async (event) => {
                    var cursor = event.target.result;
                    if ( cursor ) {
                        let sessionObj = cursor.value
                        await pre_update(part_id,sessionObj)
                        const request = cursor.update(sessionObj);
                        request.onsuccess = async () => {
                            await post_update(part_id,this.current_session_name,sessionObj)
                            resolve(true)
                        };
                    }
                    resolve(false)
                }
            }
            //
            let not_found_callback = () => {
                warn(`The session ${sess_name} is not in the database`)
                resolve(false)
            }
            //
            this._apply_find_by_name(this.current_session_name, dataStore, update_list_elem_callback, not_found_callback)    

        })

        return p
    }



    //  remove_data: 
    //      Parameters: part_id -- remove a sections of the data kept by the session named sess_name
    //                  sess_name -- A session or separate project or publication...
    //
    remove_data(part_id,sess_name) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: remove_audio_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //

        let p = new Promise((resolve,reject) => {
            // remove_from_list_callback
            let remove_from_list_callback = async (value,dbIndex) => {
                let keyRangeValue = IDBKeyRange.only(value.name);
                dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                    let cursor = event.target.result;
                    if ( cursor ) {
                        let sessionObj = cursor.value
                        delete sessionObj.data[part_id]
                        //
                        const request = cursor.update(sessionObj);
                        request.onsuccess = async () => {
                            //  item has been removed
                            console.log(`deleted ${part_id}`)
                            await this.app_secure_total_session(sess_name)
                            resolve(true)
                        };
                        //
                        request.onerror = (e) => {
                            resolve(false)
                        }
                    }
                    resolve(false)
                }
            }

            // not_found_callback 
            let not_found_callback = () => {
                warn(`The session ${sess_name} is not in the database`)
                resolve(false)
            }

            this._apply_find_by_name(sess_name, dataStore, remove_from_list_callback, not_found_callback)
        })

        return p
    }
      
    //  remove_data: 
    //      Parameters: part_id -- remove a sections of the data kept by the session named sess_name
    //                  sess_name -- A session or separate project or publication...
    //
    get_data(part_id,sess_name) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: remove_audio_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //

        let p = new Promise((resolve,reject) => {
            // remove_from_list_callback
            let get_from_list_callback = async (value,dbIndex) => {
                let keyRangeValue = IDBKeyRange.only(value.name);
                dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                    let cursor = event.target.result;
                    if ( cursor ) {
                        let sessionObj = cursor.value
                        let value =  sessionObj.data[part_id]
                        if ( value === undefined ) {
                            resolve(false)
                        } else {
                            resolve(value)
                        }
                    }
                    resolve(false)
                }
            }
        
            // not_found_callback 
            let not_found_callback = () => {
                warn(`The session ${sess_name} is not in the database`)
                resolve(false)
            }
        
            this._apply_find_by_name(sess_name, dataStore, get_from_list_callback, not_found_callback)
        })

        return p
    }
      
 
    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    //  get_session: 
    //      Parameters: sess_name -- A session or separate project or publication...
    //  Returns the object controlling all the data within the session.
    get_session(sess_name) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: get_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //
        let p = new Promise((resolve,reject) => {
          //
          // get_elem_callback
          let get_elem_callback = (value,dbIndex) => {          // element.name == sess_name exists
            //
            let keyRangeValue = IDBKeyRange.only(value.name);
            //
            dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
              let cursor = event.target.result;
              if ( cursor ) {
                let sessionObj = cursor.value
                resolve(sessionObj)
              } else {
                reject(null)
              }
            }
          }
          //
          // not_found_callback
          let not_found_callback = () => {                       // element.name == sess_name  NOT FOUND
            reject(null)
          }
          //
          this._apply_find_by_name(sess_name, dataStore, get_elem_callback, not_found_callback)
        })
        //
        return p
    }

     
    //  delete_session: 
    //      Parameters: sess_name -- A session or separate project or publication...
    //
    delete_session(sess_name) {
        //
        if ( !(this._can_process_db) ) return false

        if ( sess_name !== 'none ') {
            if ( this.db === null ) {
                console.log("db not initialized :: delete_session")
                return false;
            }
            //
            let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
            if ( !(transaction) ) return false
            let dataStore = transaction.objectStore(this.DATA_STORE);
            if ( !(dataStore) ) return false
        
            let p = new Promise((resolve,reject) => {
                // delete_from_list_callback
                let delete_from_list_callback = (value,dbIndex) => {
                    //
                    let keyRangeValue = IDBKeyRange.only(value.name);
                    //
                    dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                        let cursor = event.target.result;
                        if ( cursor ) {
                            let request = cursor.delete();
                            request.onsuccess = () => {
                                this.current_session_name = 'none'   /// here last
                                this.load_name_list()
                                this.application_revise_current_session(this.current_session_name)
                                resolve(true)
                            };
                        }
                        resolve(false)
                    }
                }
                //
                let not_found_callback = () => {
                    warn(`The session ${sess_name} is not in the database`)
                    resolve(false)
                }
                //
                this._apply_find_by_name(sess_name, dataStore, delete_from_list_callback, not_found_callback)    
            })
            //
            return p
        }
        return false
    }



    async install_session(session_object) {
        if ( typeof session_object !== 'object')
        if ( !(this._can_process_db) ) return false
        if ( this.db === null ) {
            console.log("db not initialized :: delete_session")
            return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false

        //
        let request = dataStore.put(session_object)
        request.onsuccess = (ev) => {
            let rsult = event.target.result
            //
            this.current_session_name = session_object.name
        }
        //
    }


    store_completion(storeObj) {
        if ( typeof storeObj !== 'object')
        if ( !(this._can_process_db) ) return false
        if ( this.db === null ) {
            console.log("db not initialized :: delete_session")
            return false;
        }
        //
        let transaction = this.db.transaction(this.COMPLETION_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.COMPLETION_STORE);
        if ( !(dataStore) ) return false

        if ( this.COMPLETION_STORE !== undefined ) {
            let p = new Promise((resolve,reject) => {
                //
                transaction.oncomplete = (ev) => {
                    console.log("store_complete: transaction done")
                }
                transaction.onerror = (ev) => {
                    console.log(ev)
                }
                let result = dataStore.put(storeObj)
                result.onsuccess = (event) => {
                    resolve(event.target.result)
                }
                result.error = (error) => {
                    reject(error)
                }
            })
            return p
        }
        return false
    }


    get_completion(c_key) {
        //
        if ( !(this._can_process_db) ) return false
        if ( this.db === null ) {
            console.log("db not initialized :: delete_session")
            return false;
        }
        //
        let transaction = this.db.transaction(this.COMPLETION_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.COMPLETION_STORE);
        if ( !(dataStore) ) return false
        //
        let p = new Promise((resolve,reject) => {            
            let nameIndex = dataStore.index('name');
            nameIndex.get(c_key).onsuccess = (evt) => {     // KEY
                let value = evt.target.result;
                if ( value ) {
                    let keyRangeValue = IDBKeyRange.only(value.name);
                    nameIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                        let cursor = event.target.result;
                        if ( cursor ) {
                            resolve(cursor.value)
                        } else {
                            resolve(false)
                        }
                    }
                } else resolve(false)
            }
        })
        //
        return p
    }


    remove_completion(c_key) {
        if ( !(this._can_process_db) ) return false
        if ( this.db === null ) {
            console.log("db not initialized :: delete_session")
            return false;
        }
        //
        let transaction = this.db.transaction(this.COMPLETION_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.COMPLETION_STORE);
        if ( !(dataStore) ) return false
        //
        let p = new Promise((resolve,reject) => {
            //
            let p_t = new Promise((resolve,reject) => {
                transaction.oncomplete = (ev) => {
                    resolve(true)
                    console.log("remove_completion: transaction done")
                }
                transaction.onerror = (ev) => {
                    console.log(ev)
                    reject(false)
                }}
            )
            //
            let nameIndex = dataStore.index('name');
            nameIndex.get(c_key).onsuccess = async (evt) => {     // KEY
                let value = evt.target.result;
                if ( value ) {
                    let keyRangeValue = IDBKeyRange.only(value.name);
                    nameIndex.openCursor(keyRangeValue).onsuccess = async (event) => {
                        let cursor = event.target.result;
                        if ( cursor ) {
                            let request = cursor.delete();
                            request.onsuccess = async () => {
                                await p_t
                                resolve(true)
                            };
                        } else {
                            await p_t
                            resolve(false)
                        }
                    }
                } else {
                    await p_t
                    resolve(false)
                }
            }
        })
        //
        return p
    }

    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    application_data_update(blob_url,part_id,blob_data) {
        // implemented by derived method (override)
    }

    async app_secure_total_session(sess_name) {
         // implemented by derived method (override)
    }

    application_revise_current_session(sess_name) {
        // implemented by derived method (override)
    }

    application_update_session_name_selections(sess_name,name_list) {
        // implemented by derived method (override)
    }

    app_pre_update_action(blob_data,part_id,op_parameters) {
        // implemented by derived method (override)
    }

    app_post_update_action(blob_data,part_id,blob_url) {
        // implemented by derived method (override)
    }

    application_total_entry(sess_obj) {
        // implemented by derived method (override)
    }

}




//$EXPORTABLE::
/*
AppDBWrapper
*/




// ---->>>

// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
// MODULE: USER DB   (windowized)
//


/*
// user_data
{
    "name_key" : name_key,
    "name": '',
    "DOB" : "",
    "place_of_origin" : "", 
    "cool_public_info" : "", 
    "business" : false, 
    "public_key" : false,
    "signer_public_key" : false,
    "biometric" : false
}
*/


function identity_fn(data) {
    return data
}

let g_contacts = {}
function set_contact_map(contacts_map) {
    g_contacts = contacts_map
}

function contact_from_ucwid(user_ucwid) {
    let c = g_contacts[user_ucwid]
    return c
}

function name_key_of(user_info) {
    if ( (user_info.name === undefined) || (user_info.DOB === undefined) ) {
        return false
    }
    let name_key = `${user_info.name}-${user_info.DOB}`
    return name_key
}

function value_fallback(value) {
    let vv = value ? value : ""
    return vv
}


class HumanUserDB extends AppDBWrapper {

    constructor(conf) {
        super("human-user-records",conf)
        this.current_user_name = ""
        this.current_description = ""
        this.current_file_list = []
        //
        this.current_user_object = false
        this.current_user_data = false
        //
        this.clear_identity_list_data()
    }

    async add_user(user_object) {
        this.current_session_name = user_object.name
        let part_id = "user-meta"
        //
        let blob_data = user_object
        //
        blob_data = JSON.stringify(blob_data)
        await this.add_data(blob_data,part_id)
    }

    async update_user(user_object) {
        await this.add_user(user_object)
    }

    async get_user(sel_user) {
        try {
            let user_Obj = await this.get_session(sel_user)
            if ( user_Obj ) {
                //
                this.current_user_object = user_Obj
                //
                this.current_user_name = user_Obj.name
                //
                this.current_session_name = user_Obj.name
                //
                this.current_user_info = user_Obj.user_info
                //
                this.current_user_data = user_Obj.data
                //
                this.current_file_list = []
                let data_map = user_Obj.data
                for ( let part_id in data_map ) {
                    if ( part_id !== "user-meta" ) {
                        this.current_file_list.push(JSON.parse(data_map[part_id]))
                    }
                }
                //
                return user_Obj
            }
        } catch (e) {
            console.log("get_user")
        }
    }

    get_file_details(part_id) {
        if ( !(part_id) || (part_id.length === 0) ) return ""
        if ( this.current_user_object ) {
            let user_Obj = this.current_user_object
            if ( user_Obj ) {
                let data_map = user_Obj.data
                if ( typeof data_map[part_id] === "string" ) {
                    return JSON.parse(data_map[part_id])    
                }
            }
        }
        return false
    }

    //
    async add_file(file_name,description,svg,to_layer) {
        if ( svg === undefined ) svg = ""
        if ( to_layer == undefined ) to_layer = 0
        let file_record = {
            "name" : file_name, 
            "description" : description,
            "data" : "", "ouput" : "", "svg" : svg, "layer" : to_layer }
        //
        let data = JSON.stringify(file_record)
        await this.add_data(data,file_name)
    }

    //
    async remove_file(file_name) {
        this.current_session_name = this.current_user_name
        await this.remove_data(file_name,this.current_user_name)
    }

    //
    async remove_user() {
        this.current_session_name = this.current_user_name
        await this.delete_session(this.current_user_name)
    }

    // 
    async get_file_names() {
        let sess_name = this.current_session_name
        try {
            let sess_data = await this.get_session(sess_name)
            if ( sess_data ) {
                let f_names = Object.keys(sess_data.data)
                return f_names
            }    
        } catch (e) {
            console.log("get_file_names")
        }
        return []
    }

    async get_file_entries() {
        let sess_name = this.current_session_name
        try {
            let sess_data = await this.get_session(sess_name)
            if ( sess_data ) {
                let f_names = sess_data.data.map((f_data) => JSON.parse(f_data))
                return f_names
            }
        } catch (e) {
            console.log("get_file_entries")
        }
        return []    
    }

    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    app_add_fields(sessionObj) {
        sessionObj.project_name = this.current_user_name
        sessionObj.author = this.current_author
        sessionObj.description = this.current_description
    }

    application_data_update(blob_url,part_id,blob_data) {
        // implemented by derived method (override)
    }

    async app_secure_total_session(sess_name) {
         // implemented by derived method (override)
    }

    application_revise_current_session(sess_name) {
        // implemented by derived method (override)
    }

    application_update_session_name_selections(sess_name,name_list) {

    }


    clear_identity_list_data() {
        this.identity_list = []
        this.user_list = []
    }

    application_total_entry(identity) {
        this.identity_list.push(identity)
        this.user_list.push(identity.user_info)
    }


    async get_known_users() {
        this.clear_identity_list_data()
        await g_human_user_storage.load_name_list()
        return [this.user_list,this.identity_list]
    }
    

}



//$>>	db_startup

const DB_VERSION = 1
const DATA_STORE = "human-projects"
const describe_data = "user records"

let g_human_user_storage = false
let g_human_user_storage_ref = [false]

async function db_startup() {
    //
    g_human_user_storage = new HumanUserDB({
        "DB_VERSION" : DB_VERSION,
        "DATA_STORE" : DATA_STORE,
        "describe_data" : describe_data
    })

    await g_human_user_storage.init_database()
    await g_human_user_storage.load_name_list()

    g_human_user_storage_ref[0] = g_human_user_storage
    
    return g_human_user_storage
}


//$>>	store_user
// for this verision of store_user, it is assumed that the shape of the user information has been fully 
// determined by the base domain page (www.of-this.world/builder ... for instance) 
async function store_user(user_information) {
    if ( !g_human_user_storage ) return(false)
    await g_human_user_storage.add_user(user_information)
    return(true)
}


//$>>	get_known_users
async function get_known_users() {
    if ( g_human_user_storage ) {
        return await g_human_user_storage.get_known_users()
    }
    return [false,false]
}


//$>>	unstore_user
async function unstore_user(identity) {
    try {
        let name_key = identity.name
        if ( g_human_user_storage.current_user_name !== name_key ) {
            await g_human_user_storage.get_user(name_key)
        }
        await g_human_user_storage.remove_user()
        return(true)
    } catch (e) {
    }
    return false
}



//$>>	identity_from_user
async function identity_from_user(user_info) {
    let name_key = name_key_of(user_info)
    if ( !name_key ) return(false)
    //
    try {
       let identity = await g_human_user_storage.get_user(name_key)
       return identity
    } catch (e) {
    }
    return false
}

g_finalizers.unshift(db_startup)



//$EXPORTABLE::
/*
db_startup
store_user
unstore_user
identity_from_user
get_known_users
*/



// END OF DATABASE



// FETCH POST
	// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

	async function postData(url = '', data = {}, creds = 'omit', do_stringify = true) {
		// Default options are marked with *
		const response = await fetch(url, {
			method: 'POST', // *GET, POST, PUT, DELETE, etc.
			mode: 'cors', // no-cors, *cors, same-origin
			cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
			credentials: creds, // include, *same-origin, omit
			headers: {
				'Content-Type': 'application/json'
			},
			redirect: 'follow', // manual, *follow, error
			referrerPolicy: 'no-referrer', // no-referrer, *client
			body: (do_stringify ? JSON.stringify(data)  : data)	// body data type must match "Content-Type" header
		});
		if ( response.ok == false ) {
			console.log(response.status + ': ' + response.statusText)
		}
		return await response.json(); // parses JSON response into native JavaScript objects
	}

	function hide_interface_box() {
		let display = document.getElementById('interface-box')
		if ( display ) {
			display.style.visibility = "hidden"
			display.style.display = "none"
		}
	}

	function hide_box(bxname) {
		let display = document.getElementById(bxname)
		if ( display ) {
			display.style.visibility = "hidden"
			display.style.display = "none"
		}
	}

	function show_box(bxname) {
		let display = document.getElementById(bxname)
		if ( display ) {
			display.style.visibility = "visible"
			display.style.display = "block"
		}
	}

	hide_box('error-box')
	hide_box('success-box')

	async function post_submit(fields) {
		let bdy = {}
		fields.forEach(element => {
			let fld = document.getElementById(element)
			if ( fld ) {
				bdy[element] = fld.value
			}
		});
		let url = bdy.post_url
		if ( url ) {
			delete bdy.post_url
			//
			let resp = await postData(url, bdy)
			//
			if ( resp ) hide_interface_box()
			if ( resp && (resp.OK === 'true') ) {
				show_box('success-box')
			} else {
				show_box('error-box')
			}
		}
	}


// END POST WRAPPERS


// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
// MESSAGE HANDLERS



let g_frame_page = false
let g_id_builder_page = false
let g_frame_cors_uri = '*'
let g_id_builder_cors_uri = '*'

let g_builder_ready = false

let g_responder_tables = {
    "human_frame" : {
        "resolver" : false,
        "rejector" : false
    },
    "human_frame_loaded_app" : {
        "resolver" : false,
        "rejector" : false
    },
    "builder" : {
        "resolver" : false,
        "rejector" : false
    },
	"signed" : {
        "resolver" : false,
        "rejector" : false
	}
}


function alive_response(source_name) {
    if ( g_responder_tables[source_name] !== undefined ) {
        let p = new Promise((resolve,reject) => {
            g_responder_tables[source_name].resolver = (relationship,action) => {
                g_responder_tables[source_name] = {
                    "resolver" : false,
                    "rejector" : false            
                }
                resolve(true)
            }
            g_responder_tables[source_name].rejector = (relationship,action) => {
                g_responder_tables[source_name] = {
                    "resolver" : false,
                    "rejector" : false            
                }
                reject(false)
            }
        })
        return p    
    }
    return false
}



function human_page_has_app() {
	return alive_response("human_frame_loaded_app")
}



let g_until_page_reloads_identity = false
function keep_identity_for_human_frame_startup(identity) {
	g_until_page_reloads_identity = identity
}

function get_identity_for_human_frame_startup() {
	return g_until_page_reloads_identity
}


async function store_public_identity(public_component) {
	await store_user(public_component)
	// dB operation
}


async function load_public_identity() {
	// dB operation
	let [users,identities] = await get_known_users()
	if ( users && users.length ) {
		let u_record = identities[0]
		try {
			let upub = JSON.parse(u_record.data["user-meta"])
			return upub
		} catch(e) {
			console.log("parse error user data")
		}
	}
	return false
}



async function frame_page_alive() {
	// post message promise
}



// ---->>>

// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
// MESSAGE HANDLERS


// ---->>>


// SHARED CONSTANTS


// SITE PAGE
//
const SITE_PAGE_TO_FRAME = "site_page_to_frame"
const SITE_PAGE_TO_BUILDER = "site_page_to_builder"
const SITE_PAGE_TO_ALL = "RELAY"
const SITE_RELATES_TO_BUILDER = "site_page_request_id"
const SITE_RELATES_TO_FRAME = "site_page_request_action"
const SITE_RELATES_TO_ALL = "site_frame_yields_news"

// FRAME PAGE
const FRAME_PAGE_TO_HOSTED_APP = "frame_page_to_hosted_app"
const FRAME_PAGE_TO_SITE = "frame_page_to_site"
const FRAME_PAGE_TO_BUILDER = "frame_page_to_builder"
const FRAME_PAGE_TO_SERVICE_WORKER = "frame_page_to_sw"
const FRAME_PAGE_TO_WORKER = "frame_page_to_w"
const FRAME_PAGE_RELATES_TO_SITE = "frame_page_injector"
const FRAME_PAGE_RELATES_TO_BUILDER = "frame_page_reponses"
const FRAME_PAGE_RELATES_TO_SERVICE_WORKER = "frame_page_shared_action"
const FRAME_ACTION_TO_APP = "frame_page_request_action"
const FRAME_REQUEST_SESSION = "frame_page_request_session"
const FRAME_ACTION_FROM_APP = "hosted_app_requests_action"
const FRAME_PAGE_TO_PUBLISHER = "frame_page_to_publisher"
const FRAME_PAGE_RELATES_TO_PUBLISHER= "frame_page_publications"
const FRAME_ACTION_FROM_PUBLISHER = "publisher_app_requests_action"


// APP PAGE
//
const HOSTED_APP_TO_FRAME = "hosted_app_to_frame"
const HOSTED_APP_TO_ALL = "RELAY"
const APP_RELATES_TO_FRAME = "app_in_human_context"
const APP_RELATES_TO_ALL = "app_in_frame_yields_news"

// BUILDER PAGE
//
const BUILDER_PAGE_TO_FRAME = "builder_page_to_frame"
const BUILDER_PAGE_TO_SITE = "builder_page_to_site"
const BUILDER_RELATES_TO_SITE = "builder_page_injector"
const BUILDER_ACTION_TO_FRAME = "builder_page_request_action"

// HUMAN FRAME WORKER
const WORKER_TO_FRAME = "worker_to_frame"
const WORKER_RELATES_TO_FRAME = "worker_request_action"

// PUBLISHER PAGE
const HOSTED_PUBLISHER_TO_FRAME = "publisher_to_frame"
const PUBLISHER_RELATES_TO_FRAME = "publisher_ask_frame_op"

const NEW_USER_TO_FRAME = "new_user_to_frame"

// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

//
// actions
const FRAME_COMPONENT_RESPOND = "respond"
const FRAME_COMPONENT_RESPONDING = "responding"
const FRAME_ACTION_LOAD_APP = "load-app"
const FRAME_PAGE_AUTO_LOGIN = "auto-login"
const FRAME_ACTION_INSTALL = "install-id"
const FRAME_ACTION_INJECT = "inject"
const FRAME_START_SESSION = "start-session"
const FRAME_HAS_SESSION = "has-session"
const FRAME_CHECK_SESSION = "check-session"
const FRAME_NEEDS_SIGNATURE = "get-signature"
const FRAME_WANTS_SESSION = "get-session"
const FRAME_STOP_SESSION = "stop-session"
const FRAME_HAS_PERSONALIZATION = "has-personalization"
const SITE_WANTS_SIGNATURE = "send-sig-remote"
const HOST_UP_REQ_UPLOAD = "send-request-upload"
const FRAME_REQ_DATA = "send-request-respond"


const MANAGER_PAGE_TO_FRAME = "from-manager-to-frame"
const ID_MANAGER_ACTION_TO_FRAME = "id-presence-manager"
const FRAME_ACTION_REGISTER = "id-session-setup"
const FRAME_ACTION_GET_LOGIN_URL = "id-session-setup-get-login"
const FRAME_ACTION_LOGIN = "id-session-get"
const FRAME_ACTION_REMOVE = "id-manager-remove-id"
const FRAME_ACTION_UPLOAD = "id-manager-upload-id"
const FRAME_ACTION_DOWNLOAD = "id-manager-download-id"
const FRAME_ACTION_DOWNLOAD_PUBLIC = "id-manager-download-public-intro"
const FRAME_MANAGE_PICTURE_ASSET = "manager-picture-asset"
const FRAME_ACTION_ATTACH = "manager-asset-attach"

const HOST_APP_WANTS_SESSION = "session-to-app"

// categories
const FRAME_COMPONENT_SAY_ALIVE = "q-alive"
const FRAME_COMPONENT_MANAGE_ID = "m-igid"
const HOST_APP_PERSONALIZATION = "personalization"
const FRAME_TO_APP_PUBLIC_COMPONENT = "process-public-info"
const SITE_TO_FRAME_SESSIONS = "transfer-session"
const FRAME_TO_SITE_MANAGE_SESSION = "site-manage-session"
const WORKER_TO_FRAME_SESSIONS = "w-transfer-session"
const FRAME_WORKER_TO_SESSIONS = "transfer-session"
const FRAME_TO_HOSTED_APP_SESSIONS = "transfer-session"
const FRAME_TO_APP_SIGNATURE = "signed-data"
const FRAME_SIGNED = "yep-signed"
const FRAME_POSTED_PRIMARY = "yep-primary-response"
const FRAME_RAN_PUB_OP = "yep-publication-operation"

const HOSTED_APP_FILE_OPERATION = "yep-file-creation-db"
const HOSTED_APP_WORKER_OPERATION = "yep-worker-op"
const HOSTED_APP_LOAD_WORKER = "yep-worker-select"
const HOSTED_APP_INIT_WORKER = "yep-worker-ready"

const HOSTED_APP_DATA_FLIGHT = "yep-worker-dat-fly"
const HOSTED_APP_DATABASE_STORE  = "yep-data-to-db"
const HOSTED_APP_PROPERTIES = "yep-data-properties"
const HOSTED_APP_DATA_VERIFY = "yep-data-verify"
const FRAME_TO_HOSTED_APP_DATA = "yep-data-from-db"
const FRAME_LIST_DATA = "frame-lists-data-part-ids"
const FRAME_RETURNS_DATA = "frame-provides-data-part"
const FRAME_RETURNS_SESSION_CHECK = "frame-provides-session-check"

//
// window.g_message_template =

g_message_template = {
	"category" : "",
	"direction" : SITE_PAGE_TO_FRAME,
	"action" : "any",
	"relationship" : SITE_RELATES_TO_FRAME
}

let g_human_frame_url = ""
function update_frame_source(url_str) {
	let id="app-human-frame"
	let human_frame = document.getElementById(id)
	if ( human_frame !== null ) {
		g_human_frame_url = url_str
		human_frame.src = url_str
	}
}

update_frame_source("./new_user.html")


function tell_frame_page(message) {
    if ( !g_frame_page ) {
		let id="app-human-frame"
		g_frame_page = document.getElementById(id)
		if ( !(g_frame_page) ) return(false)
	}
    let msg = Object.assign({},g_message_template)
    msg.direction = SITE_PAGE_TO_FRAME
    msg.relationship = SITE_RELATES_TO_FRAME
    msg.action = message.action
    msg.category = message.category
    msg.data = message.data
    let message_str = JSON.stringify(msg)
    g_frame_page.contentWindow.postMessage(message_str,g_frame_cors_uri)
    return true
}

//const FRAME_ACTION_REGISTER = "id-session-setup"
//const FRAME_ACTION_LOGIN = "id-session-get"

function tell_human_page_auto_login(app_url) {
	let message = {
		"category" : FRAME_PAGE_AUTO_LOGIN,
		"action" : FRAME_ACTION_REGISTER,
		"data" : {
			"revise_source" : app_url,
			"use" : "login"
		}
	}
	tell_frame_page(message)
}

function tell_human_page_new_source(app_url,use = 'app') {
	let message = {
		"category" : FRAME_ACTION_LOAD_APP,
		"action" : FRAME_ACTION_LOAD_APP,
		"data" : {
			"revise_source" : app_url,
			"use" : frame_use,
			"publications" : false
		}
	}
	tell_frame_page(message)
}


async function human_frame_page_application_handlers(category,action,data,relationship) {

}


//  container (special verion) CWC
function install_new_user_response() {
    window.addEventListener("message", async (event) => {
        let page_source = event.origin
        if ( page_source !== '*' ) {
            // let opener = event.source --- the site page is assumed to be the top level of the interactions
            try {
                let mobj = JSON.parse(event.data)
                let category = mobj.category
                let relationship = mobj.relationship
                let action = mobj.action
                let direction = mobj.direction
                //
				// NEW_USER_TO_FRAME sent by `new_user.html`
                if ( direction === NEW_USER_TO_FRAME ) {		// done first when nothing about the user is in the DB
                    let _starter_page = event.source
                    if ( category === HOST_APP_PERSONALIZATION ) {
                        if ( action === FRAME_HAS_PERSONALIZATION ) {
							if ( mobj.data ) {
								update_frame_source(mobj.data)   // just change the page to the one indicated by `new_user.html`
							} else {
								await prompt_for_identity()
							}
							// then nothing else happens until a user identity builder sends partial (public) initial identity
                        }
                    }
                } else if ( direction === HOSTED_APP_TO_FRAME ) {
                    let _starter_page = event.source
                    if ( category === HOST_APP_PERSONALIZATION ) {
                        if ( action === FRAME_HAS_PERSONALIZATION ) {
                            update_frame_source(mobj.data)
                        }
                    }
				} else if ( direction === BUILDER_PAGE_TO_SITE ) {
                    if ( category === FRAME_COMPONENT_MANAGE_ID ) {
                        if ( action === FRAME_ACTION_INJECT ) {
							let public_component = mobj.data;
							if ( typeof public_component === 'object') {
								await store_public_identity(public_component)  // public to local DB
							}
                        } else if ( action === FRAME_ACTION_INSTALL ) {
							let identity = mobj.data;
							if ( typeof identity === 'object' ) {
								keep_identity_for_human_frame_startup(identity)
								if ( typeof identity.public_component === 'object' ) {
									//
									if ( identity.public_component.human_frame_url ) {
										await store_public_identity(identity.public_component)  // public to local DB
										update_frame_source(identity.public_component.human_frame_url)
										try {
											let ok = await alive_response("human_frame")
											if ( ok ) {
												let identity = get_identity_for_human_frame_startup()
												let message = {
													"category" : FRAME_COMPONENT_MANAGE_ID,
													"action" : FRAME_ACTION_INSTALL,
													"data" : identity
												}
												tell_frame_page(message)
											}
										} catch (e) {
										}
									}
									//
								}
							}
                        }
                    }
				}
            } catch (e) {
            }    
        }
    })
}


function install_frame_page_response() {
    window.addEventListener("message", async (event) => {
        let page_source = event.origin
        if ( page_source !== '*' ) {
            // let opener = event.source --- the site page is assumed to be the top level of the interactions
            try {
                let mobj = JSON.parse(event.data)
                let category = mobj.category
                let relationship = mobj.relationship
                let action = mobj.action
                let direction = mobj.direction
                //
				if ( direction === FRAME_PAGE_TO_SITE ) {
					if ( category === FRAME_COMPONENT_SAY_ALIVE ) {
						//
						if ( action === FRAME_COMPONENT_RESPONDING ) {
							// some action waiting for alive response
							if ( typeof g_responder_tables.human_frame.resolver === "function" ) {
								g_responder_tables.human_frame.resolver(relationship,action)
							}
							
							if ( typeof g_responder_tables.human_frame_loaded_app.resolver === "function" ) {
								g_responder_tables.human_frame.resolver(relationship,action)
							}
						}
						//
					} else if ( category === FRAME_WANTS_SESSION ) {
						// Go this way twice... for the PWA 
						switch ( action ) {
							case FRAME_COMPONENT_MANAGE_ID: {
								if ( mobj.data ) {
									// some action has provided data
									let id_state = mobj.data
									// "has_identity" : has_identity,
									// "identity_complete" : complete_identity
									if ( id_state.has_identity === false ) {		// when installing identity
										let pub_id = await load_public_identity()
										let id_packet = {
											"name" : pub_id.name,
											"ccwid" : pub_id.ccwid,
											"human_frame_url" : pub_id.human_frame_url,
											"name_as_uri" : pub_id.name_as_uri,
											"public_component" : pub_id
										}
										let message = {
											"category" : FRAME_COMPONENT_MANAGE_ID,
											"action" : FRAME_ACTION_INSTALL,
											"data" : id_packet
										}
										tell_frame_page(message)
									}
								}
								break;
							}
							case FRAME_ACTION_GET_LOGIN_URL: {
								tell_human_page_auto_login(LOGIN_URL)
								break;
							}
							case FRAME_ACTION_LOGIN: {
								tell_human_page_new_source(APPLICATION_URL)
								await human_page_has_app()
								let session_key = await fetch_session_key(params)   // FETCH SESSION KEY (LOGIN)
								if ( session_key ) {
									let message = {
										"category": SITE_TO_FRAME_SESSIONS,
										"action" : FRAME_HAS_SESSION,
										"data" : {
											"name" : params.name,
											"ccwid" : params.ccwid,
											"session" : session_key
										}
									}
									tell_frame_page(message)
								}
								break;
							}
						}
						//
					//			-- end FRAME_COMPONENT_SAY_ALIVE
					} else {
						let data = mobj.data
						human_frame_page_application_handlers(category,action,data,relationship)
					}
				}


            } catch (e) {
            }    
        }
    })
}



function setup_iframe_readiness_response() {
	let id="app-human-frame"
	let human_frame = document.getElementById(id)
	if ( human_frame !== null ) {
		//
		g_frame_page = human_frame

		human_frame.addEventListener('load', (evnt) => {
			if ( g_human_frame_url == evnt.target.src ) {
				let app_url = APPLICATION_URL
				tell_human_page_new_source(APPLICATION_URL)
			}
		});
		//
	}

}


async function prompt_for_identity() {
	// TBD
}




// ---- run_finalizers
async function run_finalizers() {
	for ( let fn of g_finalizers ) {
		await fn()
	}
}

async function startup() {
	await run_finalizers()
	let pub_id = await load_public_identity()
	if ( pub_id !== false ) {
		let url = pub_id.human_frame_url
		if ( url !== undefined ) {
			update_frame_source(url)
		}
	}
}

install_new_user_response()
install_frame_page_response()
startup()




/*
if (navigator.storage && navigator.storage.estimate) {
  const quota = await navigator.storage.estimate();
  // quota.usage -> Number of bytes used.
  // quota.quota -> Maximum number of bytes available.
  const percentageUsed = (quota.usage / quota.quota) * 100;
  console.log(`You've used ${percentageUsed}% of the available storage.`);
  const remaining = quota.quota - quota.usage;
  console.log(`You can write up to ${remaining} more bytes.`);
}


// QuotaExceededError
const transaction = idb.transaction(['entries'], 'readwrite');
transaction.onabort = function(event) {
  const error = event.target.error; // DOMException
  if (error.name == 'QuotaExceededError') {
    // Fallback code goes here
  }
};



// cache -- QuotaExceededError
try {
  const cache = await caches.open('my-cache');
  await cache.add(new Request('/sample1.jpg'));
} catch (err) {
  if (error.name === 'QuotaExceededError') {
    // Fallback code goes here
  }
}







// Check if site's storage has been marked as persistent
if (navigator.storage && navigator.storage.persist) {
  const isPersisted = await navigator.storage.persisted();
  console.log(`Persisted storage granted: ${isPersisted}`);
}

// Request persistent storage for site -- A PERMISSION GRANTED BY THE USER
if (navigator.storage && navigator.storage.persist) {
  const isPersisted = await navigator.storage.persist();
  console.log(`Persisted storage granted: ${isPersisted}`);
}


// If the persistent storage permission is granted, the browser will not evict data stored in:

//     Cache API
//     Cookies
//     DOM Storage (Local Storage)
//     File System API (browser-provided and sandboxed file system)
//     IndexedDB
//     Service workers
//     App Cache (deprecated, should not be used)
//     WebSQL (deprecated, should not be used)


*/




// LOGIN ACTIONS THAT IN THE PWA CONTAINER WILL BE DONE BY THE OUTER COMPONENTS
// LOGIN ACTIONS THAT IN THE PWA CONTAINER WILL BE DONE BY THE OUTER COMPONENTS


function get_auth_endpoint(endpoint) {
	let url = `${location.protocol}//${location.host}/captcha/${endpoint}`
	return url
}

function get_secondary_auth_endpoint(endpoint) {
	let url = `${location.protocol}//${location.host}/captcha/secondary/${endpoint}`
	return url
}




async function request_login(data) {
	try {
		let endpoint = get_auth_endpoint("users/login")
		let resp = await postData(endpoint, data,'include')
		if ( resp.OK === "true" ) {
			return resp.data
		} else {
			return false
		}
	} catch (e) {
		return false
	}
}


async function post_secondary_login_data(data) {
	try {
		let endpoint = get_secondary_auth_endpoint("users/login")
		let resp = await postData(endpoint, data,'include')
		if ( resp.OK === "true" ) {
			return [resp.token, resp.elements]  // token is the session_token === server side junk
		} else {
			return false
		}
	} catch (e) {
		return false
	}
}



// Each business puts this in a frame and knows how to conduct its login.
// The function must ask the frame to run private key related methods

// If captchas are being used, that is also part of the business logic.
// so, if this fetch is secondary to a captcha, then captcha handling is defined here. 
//

async function req_signature(dobj) {
	let message = {
		"category": FRAME_ACTION_FROM_APP,
		"action" : FRAME_NEEDS_SIGNATURE,
		"data" : dobj
	}
	let p = promise_decryption("signed")
	if ( p !== false ) {
		tell_frame_page(message)
		let signed = await p
		return signed
	}
	return false
}


async function fetch_session_key(public_info) {
	// public_info.signer_public_key
	// public_info.pk_key
	try {
		let login_params = {
			"action" : "login",
			"ucwid" : public_info.ccwid,
			"strategy" : "igid"
		}
		let transition = await request_login(login_params)
		if ( transition !== false ) {
			//
			let signed = await req_signature(transition)
			if ( signed ) {
				// after waiting
				let secondary  = {
					"token" : transition.token,
					"signature" : signed
				}
				// elements === { "ucwid" : ccwid }  session_key === server side key === junk
				let [session_key,elements] = await post_secondary_login_data(secondary) 
				if ( session_key ) {
					return session_key
				}
			}
		}
	} catch (e) {
	}
	return false
}



// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
let application_specific_handlers = async (category,action,relationship,params) => {
    try {
		if ( category === FRAME_TO_APP_PUBLIC_COMPONENT ) {
			switch ( action ) {
				case FRAME_COMPONENT_RESPONDING: {
					if ( params !== "fail" ) {
						let session_key = await fetch_session_key(params.public_component)   // FETCH SESSION KEY (LOGIN)
						if ( session_key ) {
							let message = {
								"category": FRAME_ACTION_FROM_APP,
								"action" : FRAME_HAS_SESSION,
								"data" : {
									"name" : params.name,
									"ccwid" : params.ccwid,
									"session" : session_key
								}
							}
							tell_frame_page(message)
						}
					}
					break
				}
				case FRAME_SIGNED: {
					let signed = params.signed
					if ( signed ) {
						g_responder_tables["signed"].resolver(signed)
					} else {
						g_responder_tables["signed"].rejector()
					}
					break
				}
			}
		}
    } catch (e) {
		console.log(e)
    }
}


// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

async function session_startup_process() {
    let message = {
        "category": FRAME_ACTION_FROM_APP,
        "action" : FRAME_START_SESSION,
        "data" : false
    }
    tell_frame_page(message)
}


</script>