<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

<!-- MANIFEST... -->
	<link rel="manifest" href="./manifest.json" />
<!-- ... -->

	<meta name="author" content="Richard Leddy" />
	<meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
	<meta id="theme-color" name="theme-color" content="#452770">

	<link rel="canonical" href="http://www.copious.world">
	<link rel="icon" type="image/svg+xml" href="./copiousLogo.svg" />

	<!-- metas for PWA -->
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="default">
	<meta name="apple-mobile-web-app-title" content="copious-world-container">

<style>

  button {
    cursor: pointer;
  }
  button:disabled {
    cursor:default;
  }

  audio {
    display: block;
    margin: 5px;
  }

  .like-button {
    font-weight: 600;
    font-size:68%;
    font-family: Arial, Helvetica, sans-serif;
    background-color: rgb(250, 244, 218);
    margin-right: 4px;
    margin-left: 2px;
  }

  .wv_button {
    width: fit-content;
  }

  .wv_button_wordy {
    width: 70%;
    font-size: 80%;
  }

  #saved-audio-messages {
    max-height: 256px;
    overflow-y: scroll;
  }


  .audio-checks {
    float: left
  }
  .audio-playback {
    display: inline;
  }
  .playback-div {
    width:100%;
    text-align:left;
    vertical-align:bottom;
    border-bottom: midnightblue solid 1px;
    padding: 2px;
  }
  .pop-name-list {
    visibility: hidden;
    display: none;
  }
  .pop-name-list-popped {
    visibility: visible;
    display: block;
  }

  .wave-graph-container {
    left: 10px;
    top: 10px;
    width: 80%;
    height: 40%;
    position:absolute;
    display: none;
    visibility: none;
    z-index:500;
    border: 2px orangered solid;
    background-color: ivory;
  }

  .wave-graph-container button {
    font-size: 0.8em;
    cursor: pointer;
    font-weight: 600;
    background-color: rgb(250, 244, 218);
    border-radius: 6px;
    border: 1px double #cccccc;
    width:auto;
    padding-left: 4px;
    padding-right: 4px;
  }

  .drag-bar-control {
    margin:0px;
    width: 100%;
    height: 20px;
    background-color: slateblue;
    color:goldenrod;
    cursor:move;
    text-align: right;
  }
  .wave-graph-canvas {
    width: 100%;
    height: 100%;
  }
  .wv-editor-close {
    font-size: 120%;
    height:10px;
    width:10px;
    text-align: center;
    vertical-align: middle;
    cursor: pointer;
  }
  .wave_edit_controls_container {
    display:inline-block;
    width: calc(100% - 20px);
    text-align: center;
    height: 100%;
  }

  dialog {
    padding: 0;
    border: 0;
    border-radius: 0.4rem;
    padding: 6px;
    box-shadow: 0 0 1em black;
    background-color: rgb(221, 214, 221);
  }

  dialog::backdrop {
    background: rgba(200, 200, 160, 0.25);
  }

  .wv-bq-dialog {
    max-width: 600px;
    border:rgb(250, 244, 218) solid 1px;
    background-color: rgba(255, 245, 238, 0.603);
    color:rgb(24, 57, 83);
    font-weight:400;
  }

  .check_audio_element {
    min-height: 50px;
  }

  #audioBoxGhost {
    position : absolute;
    display : none;
    visibility: hidden;
    height : 0px;
    width : 0px;
    cursor : move;
    border : 2px dotted greenyellow;
    background-color: rgba(236, 236, 201, 0.445);
  }



  .component-container {
    border: rgb(126, 79, 9) solid 2px;
    padding: 4px;
    display: block;
    top: 0px;
    height: calc(100vh - 50px);
  }

  .boxes {
    position : absolute;
    top:0px;
    bottom:0px;
    width: 100vw;
    border: 1px solid rgb(41, 29, 120);
  }

  #select-mode {
    padding-top: 8px;
    padding-left: 10%;
    background-color: rgb(249, 247, 236);
    height:28px;
    border: 1px solid rgb(72, 3, 3);
    width: calc(100vw - 10% - 2px);
  }

</style>
</head>
<body>
<div style="width:100%">
  <div class="boxes">
    <div id="select-mode" >
      <button id="btn-pick_recorder" onclick="show_recorder(event)">recorder</button>&nbsp;
      <button id="btn-pick_manager" onclick="show_manager(event)">manage records</button>
    </div>

    <div id="big-recorder" class="component-container">
      <span style="font-weight: bolder;">Record Audio</span>:&nbsp;&nbsp;&nbsp;&nbsp;
      <span id="show-session-name" style="font-weight: bolder;"></span>
      <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 2px;">&nbsp;</div>
      <button id="record" disabled>Record</button>
      <button id="stop" disabled>Stop</button>
      <button id="play" disabled>Play</button>
      <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 12px;">&nbsp;</div>

      <img src="./microphone.svg"  />
    </div>

    <div  id="record-manager"  class="component-container" style="display: none;">
      <span style="font-weight: bolder;">Manage Recording Sessions</span>
      <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 2px;">&nbsp;</div>
      <div class="like-button" style="display: inline;" >
        <label  for="wv-geo-location">Session Geolocation:</label>
        <span id="wv-geo-location">NaN,NaN</span>
      </div>
      
      <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 12px;">&nbsp;</div>
      <button class="wv_button" onclick="ask_user_session()" >New&nbsp;Recording&nbsp;Session</button>
      <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 2px;">&nbsp;</div>
      <!--   -->
      <div class="like-button" style="display: inline;" >
      <label  for="sess-names" style="text-align: left;">Edit Existing Session:</label>
      <select name="sess-names" id="sess-names" onchange="edit_user_session(event)">
        <option value="none">no selection</option>
      </select>
      </div>
      <!--   -->
      <div>
      <button class="wv_button" id="send-session" onclick="download_prompt()" >Download&nbsp;Session</button>
      <button class="wv_button_wordy" id="delete-session" onclick="delete_session()" >Delete&nbsp;Session&nbsp;from&nbsp;Device</button>
      </div>
      <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 12px;">&nbsp;</div>
      <!--   -->
    
      <span style="font-weight: bolder;">Save Audio</span>
      <div style="max-height: 1px; background-color: rgb(12, 4, 4);width: 100%;margin-bottom: 2px;">&nbsp;</div>
      <button id="save" disabled>Save</button>
      <button id="delete" disabled>Delete</button>
      <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 12px;">&nbsp;</div>
      <div style="width: 98%;">
        <div style="font-weight: bolder;">Session Components:</div>
        <div style="display: inline;padding:2px;background-color: oldlace">
          <button class="wv_button" onclick="wv_edit_checked()" >edit&nbsp;checked</button>
          <button class="wv_button" onclick="wv_delete_checked()" >delete&nbsp;checked</button>
        </div>
      </div>
      <div style="max-height: 1px; background-color: maroon;width: 100%;margin-bottom: 2px;;margin-top: 2px;">&nbsp;</div>
      <div id="saved-audio-messages">
      </div>
    </div>
    
  </div>

</div>


<div id="wave-graph-tmplt" class='wave-graph-container'>
  <div class="drag-bar-control"
        onmousedown="wv_capture_cursor(event)"
        onmouseup="wv_release_captured_cursor(event,false)"
        onmouseout="wv_track_cursor_out(event,true)"
        onmousemove="wv_track_cursor(event)"
        onmouseenter="wv_check_cursor_entry(event)"
      >
        <div class="wave_edit_controls_container"
          onmousedown="wv_capture_cursor(event,1)"
          onmouseup="wv_release_captured_cursor(event,false,1)"
          onmouseout="wv_track_cursor_out(event,true,1)"
          onmousemove="wv_track_cursor(event,1)"
          onmouseenter="wv_check_cursor_entry(event,1)"
          >
          <button onclick="wv_zoom_in(event)">&downarrow;</button>
          <button onclick="wv_zoom_out(event)">&uparrow;</button>
          <button onclick="wv_scroll_left(event)">&leftarrow;</button>
          <button onclick="wv_scroll_right(event)">&rightarrow;</button>
          &nbsp;
          <button onclick="wv_cut_selection(event)">cut</button>
          <button onclick="wv_restore_selection(event)">undo</button>
        </div>
        <span class="wv-editor-close" onclick="wv_closer_editor(event)">x</span></div>
  <div style="width: 100%;height:calc(100% - 20px);">
    <canvas class="wave-graph-canvas"></canvas>
  </div>
</div>

<!-- wave template-->

<dialog id='wave-download-box'>
  <h3 class="modal-header">Click on the link below to begin downloading an audio file of this session</h3>
  <div class="modal-body">
    <blockquote class="wv-bq-dialog">
      <a id='wave-download-link' href = "" >no file</a>
    </blockquote>
  </div>
  <footer class="modal-footer">
    <button id="wave-download-cancel" type="button">Cancel</button>
  </footer>
</dialog>
<!-- end of dialog-->

<div id="audioBoxGhost" >
    &nbsp;
</div>
</body>

<script>


//
// SHARED CONSTANTS

// SITE PAGE
//
const SITE_PAGE_TO_FRAME = "site_page_to_frame"
const SITE_PAGE_TO_BUILDER = "site_page_to_builder"
const SITE_PAGE_TO_ALL = "RELAY"
const SITE_RELATES_TO_BUILDER = "site_page_request_id"
const SITE_RELATES_TO_FRAME = "site_page_request_action"
const SITE_RELATES_TO_ALL = "site_frame_yields_news"

// FRAME PAGE
const FRAME_PAGE_TO_HOSTED_APP = "frame_page_to_hosted_app"
const FRAME_PAGE_TO_SITE = "frame_page_to_site"
const FRAME_PAGE_TO_BUILDER = "frame_page_to_builder"
const FRAME_PAGE_TO_SERVICE_WORKER = "frame_page_to_sw"
const FRAME_PAGE_TO_WORKER = "frame_page_to_w"
const FRAME_PAGE_RELATES_TO_SITE = "frame_page_injector"
const FRAME_PAGE_RELATES_TO_BUILDER = "frame_page_reponses"
const FRAME_PAGE_RELATES_TO_SERVICE_WORKER = "frame_page_shared_action"
const FRAME_ACTION_TO_APP = "frame_page_request_action"
const FRAME_REQUEST_SESSION = "frame_page_request_session"
const FRAME_ACTION_FROM_APP = "hosted_app_requests_action"
const FRAME_PAGE_TO_PUBLISHER = "frame_page_to_publisher"
const FRAME_PAGE_RELATES_TO_PUBLISHER= "frame_page_publications"
const FRAME_ACTION_FROM_PUBLISHER = "publisher_app_requests_action"

// APP PAGE
//
const HOSTED_APP_TO_FRAME = "hosted_app_to_frame"
const HOSTED_APP_TO_ALL = "RELAY"
const APP_RELATES_TO_FRAME = "app_in_human_context"
const APP_RELATES_TO_ALL = "app_in_frame_yields_news"

// BUILDER PAGE
//
const BUILDER_PAGE_TO_FRAME = "builder_page_to_frame"
const BUILDER_PAGE_TO_SITE = "builder_page_to_site"
const BUILDER_RELATES_TO_SITE = "builder_page_injector"
const BUILDER_ACTION_TO_FRAME = "builder_page_request_action"

// HUMAN FRAME WORKER
const WORKER_TO_FRAME = "worker_to_frame"
const WORKER_RELATES_TO_FRAME = "worker_request_action"

// PUBLISHER PAGE
const HOSTED_PUBLISHER_TO_FRAME = "publisher_to_frame"
const PUBLISHER_RELATES_TO_FRAME = "publisher_ask_frame_op"

// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

//
// actions
const FRAME_COMPONENT_RESPOND = "respond"
const FRAME_COMPONENT_RESPONDING = "responding"
const FRAME_ACTION_LOAD_APP = "load-app"
const FRAME_ACTION_INSTALL = "install-id"
const FRAME_ACTION_INJECT = "inject"
const FRAME_START_SESSION = "start-session"
const FRAME_HAS_SESSION = "has-session"
const FRAME_CHECK_SESSION = "check-session"
const FRAME_NEEDS_SIGNATURE = "get-signature"
const FRAME_WANTS_SESSION = "get-session"
const FRAME_STOP_SESSION = "stop-session"
const FRAME_HAS_PERSONALIZATION = "has-personalization"
const SITE_WANTS_SIGNATURE = "send-sig-remote"
const HOST_UP_REQ_UPLOAD = "send-request-upload"
const FRAME_REQ_DATA = "send-request-respond"


const MANAGER_PAGE_TO_FRAME = "from-manager-to-frame"
const ID_MANAGER_ACTION_TO_FRAME = "id-presence-manager"
const FRAME_ACTION_REMOVE = "id-manager-remove-id"
const FRAME_ACTION_UPLOAD = "id-manager-upload-id"
const FRAME_ACTION_DOWNLOAD = "id-manager-download-id"
const FRAME_ACTION_DOWNLOAD_PUBLIC = "id-manager-download-public-intro"
const FRAME_MANAGE_PICTURE_ASSET = "manager-picture-asset"
const FRAME_ACTION_ATTACH = "manager-asset-attach"

const HOST_APP_WANTS_SESSION = "session-to-app"

// categories
const FRAME_COMPONENT_SAY_ALIVE = "q-alive"
const FRAME_COMPONENT_MANAGE_ID = "m-igid"
const HOST_APP_PERSONALIZATION = "personalization"
const FRAME_TO_APP_PUBLIC_COMPONENT = "process-public-info"
const SITE_TO_FRAME_SESSIONS = "transfer-session"
const FRAME_TO_SITE_MANAGE_SESSION = "site-manage-session"
const WORKER_TO_FRAME_SESSIONS = "w-transfer-session"
const FRAME_WORKER_TO_SESSIONS = "transfer-session"
const FRAME_TO_HOSTED_APP_SESSIONS = "transfer-session"
const FRAME_TO_APP_SIGNATURE = "signed-data"
const FRAME_SIGNED = "yep-signed"
const FRAME_POSTED_PRIMARY = "yep-primary-response"
const FRAME_RAN_PUB_OP = "yep-publication-operation"

const HOSTED_APP_FILE_OPERATION = "yep-file-creation-db"
const HOSTED_APP_WORKER_OPERATION = "yep-worker-op"
const HOSTED_APP_LOAD_WORKER = "yep-worker-select"
const HOSTED_APP_INIT_WORKER = "yep-worker-ready"
const HOSTED_APP_DATA_FLIGHT = "yep-worker-dat-fly"
const HOSTED_APP_DATABASE_STORE  = "yep-data-to-db"
const HOSTED_APP_PROPERTIES = "yep-data-properties"
const HOSTED_APP_DATA_VERIFY = "yep-data-verify"
const FRAME_TO_HOSTED_APP_DATA = "yep-data-from-db"
const FRAME_LIST_DATA = "frame-lists-data-part-ids"
const FRAME_RETURNS_DATA = "frame-provides-data-part"
const FRAME_RETURNS_SESSION_CHECK = "frame-provides-session-check"

// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

let g_user_current_session = false
let g_current_user_id = false
let g_current_user_name = false
let g_current_pub_identity = false

// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

var g_current_session = false


const g_message_template =  {
                                "category" : "",
                                "direction" : "",
                                "action" : "",
                                "relationship" : ""
                            }

/// END OF CONSTANTS  (ALPHA)




// Data for persistence storage...
// This is the same meta as in the file uploader
function create_asset_meta(info_obj) {
    let field_vars = {}
    field_vars['asset-id'] = false
    field_vars['rec-file-mtype'] = "audio/x-wav"
    field_vars['rec-title'] = info_obj.name
    field_vars['rec-subject'] = "New asset - " + Date.now()
    field_vars['rec-keys'] = ""
    field_vars['rec-abstract'] = ""
    field_vars['rec-full-text'] = ""
    //
    field_vars['paid-checkbox'] = false
    field_vars['WIP-checkbox'] = true
    field_vars['rec-contract'] = false
    //
    field_vars['rec-file-name'] = info_obj.name
    field_vars['rec-file-proper'] = info_obj
    field_vars['rec-poster-name'] = ""
    field_vars['rec-poster-proper'] = false
    //
    field_vars['rec-was-published'] = false
    field_vars['rec-was-uploaded'] = false
    return field_vars
}



const AUDIO_SESSION_STORE = 'audio_sessions'
const AUDIO_USERID_STORE = 'audio_users'
const AUDIO_SESSION_COMPLETE = 'audio_complete'
//
const WV_CONST_MOUSE_DRAG_DIST_TOLERANCE = 82
const WAVE_DISPLAY_MAX = 100
const ZERO_AXIS_OFFSET = 10
const THIRTY_SECONDS = 30000
const GEO_UPDATE_INTERVAL = THIRTY_SECONDS
const DB_VERSION = 5.0

const MILSEC_CHUNK_INTERVAL = 500  // every half second

// Send entire session data to the server for later placement on another device belonging to the current user.
const REQ_AUDIO_SESSION_TRANSFER = '/song-search/guarded/dynamic/audio-session-transfer'
//const REQ_WORKER_CODE = `https://${self.location.host}/song-search/static/ownership`  idea is to require a session to acquire
const REQ_WORKER_CODE = `./ownership.js`








//
let recorder = false
let audio = false
let g_app_recoder = false
let g_current_session_name = 'none'
let g_current_sesion_id = ''
let g_session_name_list = []
let g_preferred_download_format = 'audio/mpeg'
let g_wave_current_container = null

//
let g_wave_open_editors = {}
let g_wv_current_locaion = { 'latitude' : NaN,'longitude' : NaN}
let g_save_up_audio_elements = {}
let g_pub_verification_key = ""

//
let g_nonce_buffer = new Uint8Array((128/8))    // 16 bytes or 128 bit IV for AES

//
const g_recordButton = document.getElementById('record');
const g_stopButton = document.getElementById('stop');
const g_playButton = document.getElementById('play');
const g_saveButton = document.getElementById('save');
const g_deleteButton = document.getElementById('delete');
const g_send_session = document.getElementById('send-session')
//
const savedAudioMessagesContainer = document.querySelector('#saved-audio-messages');

// MODAL DIALOGS
const g_audio_download_modal = document.getElementById('wave-download-box')
//

var g_geo_update = null

var g_window_can_process = true
// In the following line, you should include the prefixes of implementations you want to test.


// INDEXED DB DEFIND IN CONTAINING WINDOW .... this code is loaded lazily and attached in the window context


window.AudioContext = window.AudioContext || window.webkitAudioContext;
//

var g_beeper_snd = new Audio("data:audio/wav;base64,//uQRAAAAWMSLwUIYAAsYkXgoQwAEaYLWfkWgAI0wWs/ItAAAGDgYtAgAyN+QWaAAihwMWm4G8QQRDiMcCBcH3Cc+CDv/7xA4Tvh9Rz/y8QADBwMWgQAZG/ILNAARQ4GLTcDeIIIhxGOBAuD7hOfBB3/94gcJ3w+o5/5eIAIAAAVwWgQAVQ2ORaIQwEMAJiDg95G4nQL7mQVWI6GwRcfsZAcsKkJvxgxEjzFUgfHoSQ9Qq7KNwqHwuB13MA4a1q/DmBrHgPcmjiGoh//EwC5nGPEmS4RcfkVKOhJf+WOgoxJclFz3kgn//dBA+ya1GhurNn8zb//9NNutNuhz31f////9vt///z+IdAEAAAK4LQIAKobHItEIYCGAExBwe8jcToF9zIKrEdDYIuP2MgOWFSE34wYiR5iqQPj0JIeoVdlG4VD4XA67mAcNa1fhzA1jwHuTRxDUQ//iYBczjHiTJcIuPyKlHQkv/LHQUYkuSi57yQT//uggfZNajQ3Vmz+Zt//+mm3Wm3Q576v////+32///5/EOgAAADVghQAAAAA//uQZAUAB1WI0PZugAAAAAoQwAAAEk3nRd2qAAAAACiDgAAAAAAABCqEEQRLCgwpBGMlJkIz8jKhGvj4k6jzRnqasNKIeoh5gI7BJaC1A1AoNBjJgbyApVS4IDlZgDU5WUAxEKDNmmALHzZp0Fkz1FMTmGFl1FMEyodIavcCAUHDWrKAIA4aa2oCgILEBupZgHvAhEBcZ6joQBxS76AgccrFlczBvKLC0QI2cBoCFvfTDAo7eoOQInqDPBtvrDEZBNYN5xwNwxQRfw8ZQ5wQVLvO8OYU+mHvFLlDh05Mdg7BT6YrRPpCBznMB2r//xKJjyyOh+cImr2/4doscwD6neZjuZR4AgAABYAAAABy1xcdQtxYBYYZdifkUDgzzXaXn98Z0oi9ILU5mBjFANmRwlVJ3/6jYDAmxaiDG3/6xjQQCCKkRb/6kg/wW+kSJ5//rLobkLSiKmqP/0ikJuDaSaSf/6JiLYLEYnW/+kXg1WRVJL/9EmQ1YZIsv/6Qzwy5qk7/+tEU0nkls3/zIUMPKNX/6yZLf+kFgAfgGyLFAUwY//uQZAUABcd5UiNPVXAAAApAAAAAE0VZQKw9ISAAACgAAAAAVQIygIElVrFkBS+Jhi+EAuu+lKAkYUEIsmEAEoMeDmCETMvfSHTGkF5RWH7kz/ESHWPAq/kcCRhqBtMdokPdM7vil7RG98A2sc7zO6ZvTdM7pmOUAZTnJW+NXxqmd41dqJ6mLTXxrPpnV8avaIf5SvL7pndPvPpndJR9Kuu8fePvuiuhorgWjp7Mf/PRjxcFCPDkW31srioCExivv9lcwKEaHsf/7ow2Fl1T/9RkXgEhYElAoCLFtMArxwivDJJ+bR1HTKJdlEoTELCIqgEwVGSQ+hIm0NbK8WXcTEI0UPoa2NbG4y2K00JEWbZavJXkYaqo9CRHS55FcZTjKEk3NKoCYUnSQ0rWxrZbFKbKIhOKPZe1cJKzZSaQrIyULHDZmV5K4xySsDRKWOruanGtjLJXFEmwaIbDLX0hIPBUQPVFVkQkDoUNfSoDgQGKPekoxeGzA4DUvnn4bxzcZrtJyipKfPNy5w+9lnXwgqsiyHNeSVpemw4bWb9psYeq//uQZBoABQt4yMVxYAIAAAkQoAAAHvYpL5m6AAgAACXDAAAAD59jblTirQe9upFsmZbpMudy7Lz1X1DYsxOOSWpfPqNX2WqktK0DMvuGwlbNj44TleLPQ+Gsfb+GOWOKJoIrWb3cIMeeON6lz2umTqMXV8Mj30yWPpjoSa9ujK8SyeJP5y5mOW1D6hvLepeveEAEDo0mgCRClOEgANv3B9a6fikgUSu/DmAMATrGx7nng5p5iimPNZsfQLYB2sDLIkzRKZOHGAaUyDcpFBSLG9MCQALgAIgQs2YunOszLSAyQYPVC2YdGGeHD2dTdJk1pAHGAWDjnkcLKFymS3RQZTInzySoBwMG0QueC3gMsCEYxUqlrcxK6k1LQQcsmyYeQPdC2YfuGPASCBkcVMQQqpVJshui1tkXQJQV0OXGAZMXSOEEBRirXbVRQW7ugq7IM7rPWSZyDlM3IuNEkxzCOJ0ny2ThNkyRai1b6ev//3dzNGzNb//4uAvHT5sURcZCFcuKLhOFs8mLAAEAt4UWAAIABAAAAAB4qbHo0tIjVkUU//uQZAwABfSFz3ZqQAAAAAngwAAAE1HjMp2qAAAAACZDgAAAD5UkTE1UgZEUExqYynN1qZvqIOREEFmBcJQkwdxiFtw0qEOkGYfRDifBui9MQg4QAHAqWtAWHoCxu1Yf4VfWLPIM2mHDFsbQEVGwyqQoQcwnfHeIkNt9YnkiaS1oizycqJrx4KOQjahZxWbcZgztj2c49nKmkId44S71j0c8eV9yDK6uPRzx5X18eDvjvQ6yKo9ZSS6l//8elePK/Lf//IInrOF/FvDoADYAGBMGb7FtErm5MXMlmPAJQVgWta7Zx2go+8xJ0UiCb8LHHdftWyLJE0QIAIsI+UbXu67dZMjmgDGCGl1H+vpF4NSDckSIkk7Vd+sxEhBQMRU8j/12UIRhzSaUdQ+rQU5kGeFxm+hb1oh6pWWmv3uvmReDl0UnvtapVaIzo1jZbf/pD6ElLqSX+rUmOQNpJFa/r+sa4e/pBlAABoAAAAA3CUgShLdGIxsY7AUABPRrgCABdDuQ5GC7DqPQCgbbJUAoRSUj+NIEig0YfyWUho1VBBBA//uQZB4ABZx5zfMakeAAAAmwAAAAF5F3P0w9GtAAACfAAAAAwLhMDmAYWMgVEG1U0FIGCBgXBXAtfMH10000EEEEEECUBYln03TTTdNBDZopopYvrTTdNa325mImNg3TTPV9q3pmY0xoO6bv3r00y+IDGid/9aaaZTGMuj9mpu9Mpio1dXrr5HERTZSmqU36A3CumzN/9Robv/Xx4v9ijkSRSNLQhAWumap82WRSBUqXStV/YcS+XVLnSS+WLDroqArFkMEsAS+eWmrUzrO0oEmE40RlMZ5+ODIkAyKAGUwZ3mVKmcamcJnMW26MRPgUw6j+LkhyHGVGYjSUUKNpuJUQoOIAyDvEyG8S5yfK6dhZc0Tx1KI/gviKL6qvvFs1+bWtaz58uUNnryq6kt5RzOCkPWlVqVX2a/EEBUdU1KrXLf40GoiiFXK///qpoiDXrOgqDR38JB0bw7SoL+ZB9o1RCkQjQ2CBYZKd/+VJxZRRZlqSkKiws0WFxUyCwsKiMy7hUVFhIaCrNQsKkTIsLivwKKigsj8XYlwt/WKi2N4d//uQRCSAAjURNIHpMZBGYiaQPSYyAAABLAAAAAAAACWAAAAApUF/Mg+0aohSIRobBAsMlO//Kk4soosy1JSFRYWaLC4qZBYWFRGZdwqKiwkNBVmoWFSJkWFxX4FFRQWR+LsS4W/rFRb/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VEFHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU291bmRib3kuZGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAwNGh0dHA6Ly93d3cuc291bmRib3kuZGUAAAAAAAAAACU=");  
function beep() {
  g_beeper_snd.play();
}
//beep()

const g_audioContext = new AudioContext();






// ---->>>
// MODULE: ONE TABLE(windowized)

// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

//>>  AppDBWrapper


// In the following line, you should include the prefixes of implementations you want to test.
window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
// DON'T use "var indexedDB = ..." if you're not in a function.
// Moreover, you may need references to some window.IDB* objects:
window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction || {READ_WRITE: "readwrite"}; // This line should only be needed if it is needed to support the object's constants for older browsers
window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;
// (Mozilla has never prefixed these objects, so we don't need window.mozIDB*)


/*

// autoIncrement set to true  (for this special case DB use )

DB_VERSION
DATA_STORE
describe_data

*/


function warn(str) {
    //
}


// a session is a project...
// a session object (sessionObject) is stored in the DB and may contain parts of data
// part_id identifies a part of the data (e.g. a layer or a component)

class AppDBWrapper {

    constructor(name,conf) {
        this._can_process_db = true
        if ( !(window.indexedDB) ) {
            this._can_process_db = false
            console.log("Your browser doesn't support a stable version of IndexedDB. Such and such feature will not be available.");
        }
        //
        let self = this
        // DATA_STORE
        // DB_VERSION
        // describe_data
        if ( conf ) {
            for ( let ky in conf ) {
                self[ky] = conf[ky]
            }    
        }
        //
        this.db = false
        this.current_session_name = 'none'
        this._session_name_list = []
        this.name = name
        //
    }


    set session_name(name) {
        this.current_session_name = name
    }

    get session_name() {
        return this.current_session_name
    }

    get name_list() {
        return this._session_name_list
    }

    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    init_database() {
        //
        if ( !(this._can_process_db) ) return false
        let self = this
        let db_name = this.name
        //
        let p = new Promise((resolve,reject) => {

            let request = window.indexedDB.open(db_name, this.DB_VERSION);
            //
            // <-- onerror
            request.onerror = (event) => {
                alert(`This web app will not store ${this.describe_data} without the use of computer storage.`)
            };
            
            // <-- onsuccess
            request.onsuccess = (event) => {
                //
                let db = event.target.result;
                db.onerror = (event) => {
                    console.log("Database error: " + event.target.error);
                    reject(event.target.error)
                };
                //
                self.db = db;
                resolve(db)
            }

            // <-- onupgradeneeded
            request.onupgradeneeded = (event) => {
                //
                let db = event.target.result;
                //
                if ( this.DATA_STORE !== undefined ) {
                    try {
                        let sessionObjectStore = db.createObjectStore(this.DATA_STORE, { autoIncrement : true });
                        sessionObjectStore.createIndex("name", "name", { unique: true });
                        sessionObjectStore.createIndex("sess_date_time", "sess_date_time", { unique: true });
                    } catch (e) {
                    }
                }
                if ( this.COMPLETION_STORE !== undefined ) {
                    try {
                        let completeStore = db.createObjectStore(this.COMPLETION_STORE, { autoIncrement : false, keyPath: 'name' });
                        completeStore.createIndex("name", "name", { unique: true });
                    } catch (e) {
                    }
                }

            //
            };
        })  // end of promise
        //
        return p
    }


    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    //      load_name_list
    // -- 
    load_name_list() {
        if ( !(this.db) ) return
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readonly");
        let dataStore = transaction ? transaction.objectStore(this.DATA_STORE) : false
        //
        if ( !(dataStore) ) return false
        let p = new Promise((resolve,reject) => {
            this._session_name_list = []
            let myIndex = dataStore.index('name');
            myIndex.openCursor().onsuccess = (event) => {
                let cursor = event.target.result;
                if ( cursor ) {
                    this._session_name_list.push(cursor.value.name)
                    this.application_total_entry(cursor.value)
                    cursor.continue();
                } else {
                    this.application_update_session_name_selections(this.current_session_name,this._session_name_list)
                    resolve(true)
                }
            }
        })
        //
        return p
    }

    // _apply_find_by_name
    //  -- a generic that calls success_callback when an element matches the index, or not_found_callback otherwise.
    //
    _apply_find_by_name(sess_name, store, success_callback, not_found_callback) {
        let nameIndex = store.index('name');
        nameIndex.get(sess_name).onsuccess = (evt) => {
            let value = evt.target.result;
            if ( value ) {
                if ( success_callback ) success_callback(value,nameIndex);
            } else {
                if ( not_found_callback ) not_found_callback();
            }
        };
    }

    // _add_session_to_db
    //  -- adds the session object to the db, sets up the basic fields... 
    //
    _add_session_to_db(dataStore,application_op,part_id) {
        //
        let sessionObj = {
            'name' : this.current_session_name,
            'sess_date_time' : '' + Date.now(),
            'data' : { },
            'hashes' : { },
            'edit_order' : []
        }
        //
        if ( part_id ) sessionObj.edit_order.push(part_id)
        //
        if ( (application_op !== undefined) && (typeof application_op === 'function') ) {
            application_op(sessionObj)
        }
        let request = dataStore.add(sessionObj);  // returning an async object to which handlers may be added
        return request
    }

    add_empty_session(name,application_op) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: remove_audio_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //
        this.current_session_name = name
        if ( application_op !== undefined ) {
            this._add_session_to_db(dataStore,application_op)
        } else {
            this._add_session_to_db(dataStore)
        }
    }

    //  update_session: 
    //      Parameters: sess_name -- A session or separate project or publication...
    //                  field --- the field to change (top level)
    //                  value --- set the field to this value
    //  returns: true if the session is available for update
    update_session(sess_name,field,value) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: get_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //
        let p = new Promise((resolve,reject) => {
          //
          // get_elem_callback
          let update_elem_callback = (value,dbIndex) => {          // element.name == sess_name exists
            //
            let keyRangeValue = IDBKeyRange.only(value.name);
            //
            dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
              let cursor = event.target.result;
              if ( cursor ) {
                //
                let sessionObj = cursor.value
                sessionObj[field] = value
                const request = cursor.update(sessionObj);
                request.onsuccess = async () => {
                    resolve(true)
                };

                request.onerror = (event) => {
                    resolve(false)
                }
              } else {
                resolve(false)
              }
            }
          }
          //
          // not_found_callback
          let not_found_callback = () => {                       // element.name == sess_name  NOT FOUND
            resolve(false)
          }
          //
          this._apply_find_by_name(sess_name, dataStore, update_elem_callback, not_found_callback)
        })
        //
        return p
    }


    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    // add_data -- 
    //  Parameters: blob_data -- data stored as part of the session
    //              session id could be a layer....
    add_data(blob_data,part_id) {
        if ( !(this._can_process_db) ) return false
        if ( !(this.db) ) {
          console.log(`db not initialized :: AppDBWrapper.add_data`)
          return;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false

        let p = new Promise((resolve,reject) => {
            let self = this
            // update_list_callback
            let update_list_callback = (value,dbIndex) => {     // if found update
                if ( !dbIndex || (typeof value === "undefined") ) {
                    resolve(false)
                    return;
                }
                let keyRangeValue = IDBKeyRange.only(value.name);
                dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                    let cursor = event.target.result;
                    if ( cursor ) {
                        // existing session 
                        let sessionObj = cursor.value
                        //
                        let blob_url = (typeof blob_data === 'string') ? blob_data : URL.createObjectURL(blob_data);
                        // map_id = part_id
                        // store revised data
                        sessionObj.data[part_id] = blob_data
                        // make sure the structure has been set up if not already
                        if ( sessionObj.hashes[part_id] === undefined ) {
                            sessionObj.hashes[part_id] = {}
                        }
                        if ( sessionObj.hashes[part_id].op_history === undefined ) {
                            sessionObj.hashes[part_id].op_history = []
                        }
                        // record the order in which sessions (layers) have been edited
                        sessionObj.edit_order.push(part_id)
                        //
                        // update IndexedDB
                        const request = cursor.update(sessionObj);
                        request.onsuccess = async () => {
                            try {
                                self.application_data_update(blob_url,part_id,blob_data,part_id)  // application handling of data e.g visual rep
                            } catch (e) {
                                console.log(e)
                            } finally {
                                resolve(true)
                            }
                        };

                        request.onerror = (event) => {
                            resolve(false)
                        }
                        //
                    } else {
                        resolve(false)
                    }
                }
            }
            // add_new_callback
            let add_new_callback = () => {          // if not found add a new one
                //
                let blob_url = (typeof blob_data === 'string') ? blob_data : URL.createObjectURL(blob_data);
                //
                let application_op = (sessionObj) => {
                    //
                    sessionObj.data[part_id] = blob_data
                    if ( sessionObj.hashes[part_id] === undefined ) {
                        sessionObj.hashes[part_id] = {}
                    }
                    sessionObj.hashes[part_id].op_history = []
                    //
                } 
                //
                let request = self._add_session_to_db(dataStore,application_op,part_id)
                if ( request ) {
                    request.onsuccess = (event) => {
                        self.application_data_update(blob_url,part_id,blob_data)  // application handling of data e.g visual rep
                        resolve(true)
                    };
                    request.onerror = (event) => {
                        resolve(false)
                    }
                }
                //
            }
            //
            this._apply_find_by_name(this.current_session_name, dataStore, update_list_callback, add_new_callback)    
        })
        //
        return p
    }


    // update_data

    update_data(blob_data,part_id,op_parameters) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
            console.log("db not initialized :: remove_audio_data")
            return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false

        let update_list_elem_callback = (value,dbIndex) => {
            let keyRangeValue = IDBKeyRange.only(value.name);
            dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                var cursor = event.target.result;
                if ( cursor ) {
                    let sessionObj = cursor.value
                    if ( sessionObj.data[part_id] != null ) {
                        let blob_url = URL.createObjectURL(blob_data);
                        sessionObj.data[part_id] = blob_data
                        // handle a case which should not happen
                        if ( sessionObj.hashes[part_id] === undefined ) {
                            sessionObj.hashes[part_id] = { 'op_history' : [] }
                        }
                        // update hash ops
                        let operation = this.app_pre_update_action(blob_data,part_id,op_parameters)
                        if ( !operation ) {
                            operation = {'op' : 'backup'}
                        }
                        sessionObj.hashes[part_id].op_history.push(operation)
                        //
                        const request = cursor.update(sessionObj);
                        request.onsuccess = async () => {
                            this.app_post_update_action(blob_data,part_id,blob_url)
                        };
                    }
                    //
                }
            }
        }

        let not_found_callback = () => {
            warn(`The session ${sess_name} is not in the database`)
        }

        //
        this._apply_find_by_name(this.current_session_name, dataStore, update_list_elem_callback, not_found_callback)    
    }


    // update_data_ops

    update_data_ops(part_id,pre_update,post_update) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
            console.log("db not initialized :: remove_audio_data")
            return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //
        let p = new Promise((resolve,reject) => {
            let self = this

            let add_elem_original_chunks_callback = (value,dbIndex) => {
                let keyRangeValue = IDBKeyRange.only(value.name);
                    dbIndex.openCursor(keyRangeValue).onsuccess = async (event) => {
                    var cursor = event.target.result;
                    if ( cursor ) {
                        let sessionObj = cursor.value
                        await pre_update(part_id,sessionObj)
                        const request = cursor.update(sessionObj);
                        request.onsuccess = async () => {
                            await post_update(part_id,this.current_session_name,sessionObj)
                            resolve(true)
                        };
                    }
                    resolve(false)
                }
            }
            //
            let not_found_callback = () => {
                warn(`The session ${sess_name} is not in the database`)
                resolve(false)
            }
            //
            this._apply_find_by_name(this.current_session_name, dataStore, update_list_elem_callback, not_found_callback)    

        })

        return p
    }



    //  remove_data: 
    //      Parameters: part_id -- remove a sections of the data kept by the session named sess_name
    //                  sess_name -- A session or separate project or publication...
    //
    remove_data(part_id,sess_name) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: remove_audio_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //

        let p = new Promise((resolve,reject) => {
            // remove_from_list_callback
            let remove_from_list_callback = async (value,dbIndex) => {
                let keyRangeValue = IDBKeyRange.only(value.name);
                dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                    let cursor = event.target.result;
                    if ( cursor ) {
                        let sessionObj = cursor.value
                        delete sessionObj.data[part_id]
                        //
                        const request = cursor.update(sessionObj);
                        request.onsuccess = async () => {
                            //  item has been removed
                            console.log(`deleted ${part_id}`)
                            await this.app_secure_total_session(sess_name)
                            resolve(true)
                        };
                        //
                        request.onerror = (e) => {
                            resolve(false)
                        }
                    }
                    resolve(false)
                }
            }

            // not_found_callback 
            let not_found_callback = () => {
                warn(`The session ${sess_name} is not in the database`)
                resolve(false)
            }

            this._apply_find_by_name(sess_name, dataStore, remove_from_list_callback, not_found_callback)
        })

        return p
    }
      
    //  remove_data: 
    //      Parameters: part_id -- remove a sections of the data kept by the session named sess_name
    //                  sess_name -- A session or separate project or publication...
    //
    get_data(part_id,sess_name) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: remove_audio_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //

        let p = new Promise((resolve,reject) => {
            // remove_from_list_callback
            let get_from_list_callback = async (value,dbIndex) => {
                let keyRangeValue = IDBKeyRange.only(value.name);
                dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                    let cursor = event.target.result;
                    if ( cursor ) {
                        let sessionObj = cursor.value
                        let value =  sessionObj.data[part_id]
                        if ( value === undefined ) {
                            resolve(false)
                        } else {
                            resolve(value)
                        }
                    }
                    resolve(false)
                }
            }
        
            // not_found_callback 
            let not_found_callback = () => {
                warn(`The session ${sess_name} is not in the database`)
                resolve(false)
            }
        
            this._apply_find_by_name(sess_name, dataStore, get_from_list_callback, not_found_callback)
        })

        return p
    }
      
 
    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    //  get_session: 
    //      Parameters: sess_name -- A session or separate project or publication...
    //  Returns the object controlling all the data within the session.
    get_session(sess_name) {
        //
        if ( !(this._can_process_db) ) return false
        //
        if ( this.db === null ) {
          console.log("db not initialized :: get_data")
          return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false
        //
        let p = new Promise((resolve,reject) => {
          //
          // get_elem_callback
          let get_elem_callback = (value,dbIndex) => {          // element.name == sess_name exists
            //
            let keyRangeValue = IDBKeyRange.only(value.name);
            //
            dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
              let cursor = event.target.result;
              if ( cursor ) {
                let sessionObj = cursor.value
                resolve(sessionObj)
              } else {
                reject(null)
              }
            }
          }
          //
          // not_found_callback
          let not_found_callback = () => {                       // element.name == sess_name  NOT FOUND
            reject(null)
          }
          //
          this._apply_find_by_name(sess_name, dataStore, get_elem_callback, not_found_callback)
        })
        //
        return p
    }

     
    //  delete_session: 
    //      Parameters: sess_name -- A session or separate project or publication...
    //
    delete_session(sess_name) {
        //
        if ( !(this._can_process_db) ) return false

        if ( sess_name !== 'none ') {
            if ( this.db === null ) {
                console.log("db not initialized :: delete_session")
                return false;
            }
            //
            let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
            if ( !(transaction) ) return false
            let dataStore = transaction.objectStore(this.DATA_STORE);
            if ( !(dataStore) ) return false
        
            let p = new Promise((resolve,reject) => {
                // delete_from_list_callback
                let delete_from_list_callback = (value,dbIndex) => {
                    //
                    let keyRangeValue = IDBKeyRange.only(value.name);
                    //
                    dbIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                        let cursor = event.target.result;
                        if ( cursor ) {
                            let request = cursor.delete();
                            request.onsuccess = () => {
                                this.current_session_name = 'none'   /// here last
                                this.load_name_list()
                                this.application_revise_current_session(this.current_session_name)
                                resolve(true)
                            };
                        }
                        resolve(false)
                    }
                }
                //
                let not_found_callback = () => {
                    warn(`The session ${sess_name} is not in the database`)
                    resolve(false)
                }
                //
                this._apply_find_by_name(sess_name, dataStore, delete_from_list_callback, not_found_callback)    
            })
            //
            return p
        }
        return false
    }



    async install_session(session_object) {
        if ( typeof session_object !== 'object')
        if ( !(this._can_process_db) ) return false
        if ( this.db === null ) {
            console.log("db not initialized :: delete_session")
            return false;
        }
        //
        let transaction = this.db.transaction(this.DATA_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.DATA_STORE);
        if ( !(dataStore) ) return false

        //
        let request = dataStore.put(session_object)
        request.onsuccess = (ev) => {
            let rsult = event.target.result
            //
            this.current_session_name = session_object.name
        }
        //
    }


    store_completion(storeObj) {
        if ( typeof storeObj !== 'object')
        if ( !(this._can_process_db) ) return false
        if ( this.db === null ) {
            console.log("db not initialized :: delete_session")
            return false;
        }
        //
        let transaction = this.db.transaction(this.COMPLETION_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.COMPLETION_STORE);
        if ( !(dataStore) ) return false

        if ( this.COMPLETION_STORE !== undefined ) {
            let p = new Promise((resolve,reject) => {
                //
                transaction.oncomplete = (ev) => {
                    console.log("store_complete: transaction done")
                }
                transaction.onerror = (ev) => {
                    console.log(ev)
                }
                let result = dataStore.put(storeObj)
                result.onsuccess = (event) => {
                    resolve(event.target.result)
                }
                result.error = (error) => {
                    reject(error)
                }
            })
            return p
        }
        return false
    }


    get_completion(c_key) {
        //
        if ( !(this._can_process_db) ) return false
        if ( this.db === null ) {
            console.log("db not initialized :: delete_session")
            return false;
        }
        //
        let transaction = this.db.transaction(this.COMPLETION_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.COMPLETION_STORE);
        if ( !(dataStore) ) return false
        //
        let p = new Promise((resolve,reject) => {            
            let nameIndex = dataStore.index('name');
            nameIndex.get(c_key).onsuccess = (evt) => {     // KEY
                let value = evt.target.result;
                if ( value ) {
                    let keyRangeValue = IDBKeyRange.only(value.name);
                    nameIndex.openCursor(keyRangeValue).onsuccess = (event) => {
                        let cursor = event.target.result;
                        if ( cursor ) {
                            resolve(cursor.value)
                        } else {
                            resolve(false)
                        }
                    }
                } else resolve(false)
            }
        })
        //
        return p
    }


    remove_completion(c_key) {
        if ( !(this._can_process_db) ) return false
        if ( this.db === null ) {
            console.log("db not initialized :: delete_session")
            return false;
        }
        //
        let transaction = this.db.transaction(this.COMPLETION_STORE, "readwrite");
        if ( !(transaction) ) return false
        let dataStore = transaction.objectStore(this.COMPLETION_STORE);
        if ( !(dataStore) ) return false
        //
        let p = new Promise((resolve,reject) => {
            //
            let p_t = new Promise((resolve,reject) => {
                transaction.oncomplete = (ev) => {
                    resolve(true)
                    console.log("remove_completion: transaction done")
                }
                transaction.onerror = (ev) => {
                    console.log(ev)
                    reject(false)
                }}
            )
            //
            let nameIndex = dataStore.index('name');
            nameIndex.get(c_key).onsuccess = async (evt) => {     // KEY
                let value = evt.target.result;
                if ( value ) {
                    let keyRangeValue = IDBKeyRange.only(value.name);
                    nameIndex.openCursor(keyRangeValue).onsuccess = async (event) => {
                        let cursor = event.target.result;
                        if ( cursor ) {
                            let request = cursor.delete();
                            request.onsuccess = async () => {
                                await p_t
                                resolve(true)
                            };
                        } else {
                            await p_t
                            resolve(false)
                        }
                    }
                } else {
                    await p_t
                    resolve(false)
                }
            }
        })
        //
        return p
    }

    // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

    application_data_update(blob_url,part_id,blob_data) {
        // implemented by derived method (override)
    }

    async app_secure_total_session(sess_name) {
         // implemented by derived method (override)
    }

    application_revise_current_session(sess_name) {
        // implemented by derived method (override)
    }

    application_update_session_name_selections(sess_name,name_list) {
        // implemented by derived method (override)
    }

    app_pre_update_action(blob_data,part_id,op_parameters) {
        // implemented by derived method (override)
    }

    app_post_update_action(blob_data,part_id,blob_url) {
        // implemented by derived method (override)
    }

    application_total_entry(sess_obj) {
        // implemented by derived method (override)
    }

}




//$EXPORTABLE::
/*
AppDBWrapper
*/

// DATABASE ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

var g_audio_db = null
const gc_song_db_name = "SongCatcher"
const describe_data = "wave records"

let g_audio_storage_ref = [false]

/**
 * UsersAudioDB
 * 
 * Storage of Audio components and finalized audio capture sessions.
 * 
 * Global reference this file: g_audio_db
 * 
 * Inherited methods:
 *              init_database
 *              load_name_list
 *              store_completion
 *              get_completion
 *              remove_completion
 *              //
 *              add_data
 *              update_data
 *              update_data_ops
 *              remove_data
 *              //
 *              add_empty_session
 *              get_session
 *              delete_session    (12)
 */


class UsersAudioDB extends AppDBWrapper {   // This page component is embedded in a page that includes the AppDBWrapper

  constructor(conf) {
      super(gc_song_db_name,conf)
      this.current_user_name = ""
      this.current_description = ""
      this.current_file_list = []
      //
      this.current_user_object = false
      this.current_user_data = false
      //
      this.clear_identity_list_data()
  }


  set session_name(name) {
        this.current_session_name = name
        g_current_session_name = name
  }


  get_file_details(part_id) {
      if ( !(part_id) || (part_id.length === 0) ) return ""
      if ( this.current_user_object ) {
          let user_Obj = this.current_user_object
          if ( user_Obj ) {
              let data_map = user_Obj.data
              if ( typeof data_map[part_id] === "string" ) {
                  return JSON.parse(data_map[part_id])    
              }
          }
      }
      return false
  }

  //
  async add_file(file_name,description,svg,to_layer) {
      if ( svg === undefined ) svg = ""
      if ( to_layer == undefined ) to_layer = 0
      let file_record = {
          "name" : file_name, 
          "description" : description,
          "data" : "", "ouput" : "", "svg" : svg, "layer" : to_layer }
      //
      let data = JSON.stringify(file_record)
      await this.add_data(data,file_name)
  }

  //
  async remove_file(file_name) {
      this.session_name = file_name
      await this.remove_data(file_name,this.current_user_name)
  }

  // 
  async get_file_names() {
      let sess_name = this.session_name
      try {
          let sess_data = await this.get_session(sess_name)
          if ( sess_data ) {
              let f_names = Object.keys(sess_data.data)
              return f_names
          }    
      } catch (e) {
          console.log("get_file_names")
      }
      return []
  }

  async get_file_entries() {
      let sess_name = this.session_name
      try {
          let sess_data = await this.get_session(sess_name)
          if ( sess_data ) {
              let f_names = sess_data.data.map((f_data) => JSON.parse(f_data))
              return f_names
          }
      } catch (e) {
          console.log("get_file_entries")
      }
      return []    
  }

  // // // // // // // // // // // // // // // // // // // // // // // // // // // // 

  app_add_fields(sessionObj) {
      sessionObj.project_name = this.current_user_name
      sessionObj.author = this.current_author
      sessionObj.description = this.current_description
  }



  // _add_session_to_db
  //  -- adds the session object to the db, sets up the basic fields... 
  //
  _add_session_to_db(dataStore,application_op,part_id) {
    let sess_loc_str = JSON.stringify(g_wv_current_locaion)
    //
    let sessionObj = {
        'name' : this.session_name,
        'sess_date_time' : '' + Date.now(),
        'sess_geo_location' : sess_loc_str,
        'data' : { },
        'original_chunks' : { },      // base64 encoded
        'key_per_part' : {},
        'hashes' : { },
        'edit_order' : [],
        'locations' : [sess_loc_str]
    }
    //
    if ( part_id ) sessionObj.edit_order.push(part_id)
    //
    if ( (application_op !== undefined) && (typeof application_op === 'function') ) {
        application_op(sessionObj)
    }
    let request = dataStore.add(sessionObj);
    return request
  }

  // ----
  async application_data_update(blob_url,part_id,blob_data,other_id) {
      // implemented by derived method (override)
      add_audio_element(blob_url,part_id,audioBlob,other_id)
      if ( other_id !== undefined ) {
        await wv_secure_total_session(this.session_name)
      }
  }


  // ----
  app_pre_update_action(blob_data,part_id,op_parameters) {
        // implemented by derived method (override)
        let operation = {'op' : 'backup'}
        if ( op_parameters ) {
            let operation = {'op' : 'cut', "startX" :  op_parameters.startX, "w" : op_parameters.w, "samples" : op_parameters.samplePP }
        }
        wv_secure('edit-update',blob_data,part_id)
        return operation
  }

  // ----
  async app_post_update_action(blob_data,part_id,blob_url) {
    update_audio_element(blob_url,part_id,blob_data)  // visual rep
    await wv_secure_total_session(this.session_name)
  }

  //
  async app_secure_total_session(sess_name) {
      // implemented by derived method (override)
  }

  //
  application_revise_current_session(sess_name) {
      // implemented by derived method (override)
      this.current_session_name = sess_name
      choose_edit_user_session(this.session_name)
  }
  
  //
  application_update_session_name_selections(sess_name,name_list) {
  }

  //
  clear_identity_list_data() {
      this.identity_list = []
      this.user_list = []
  }

  application_total_entry(identity) {
      this.identity_list.push(identity)
      this.user_list.push(identity.user_info)
  }


  async get_known_users() {
      this.clear_identity_list_data()
      await g_human_user_storage.load_name_list()
      return [this.user_list,this.identity_list]
  }

}
// END OF UsersAudioDB class definition



// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----



async function wv_init_database() {
  // request an open of DB
  let p = new Promise(async (resolve,reject) => {
    g_audio_db = new UsersAudioDB({         // This page component is embedded in a page that includes the AppDBWrapper
        "DB_VERSION" : DB_VERSION,
        "DATA_STORE" : AUDIO_SESSION_STORE,
        "COMPLETION_STORE" : AUDIO_SESSION_COMPLETE,
        "describe_data" : describe_data
    })

    try {
      await g_audio_db.init_database()
      await g_audio_db.load_name_list()

      g_audio_storage_ref[0] = g_audio_db
      
      resolve(g_audio_db)
    } catch (e) {
      reject(false)
    }
  })
  //
  return p
};







// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----


// HOSTED APP PAGE COM
//
if ( typeof g_message_template === undefined ) {
    window.g_message_template = g_message_template = {
        "category" : "",
        "direction" : "",
        "action" : "",
        "relationship" : ""
    }
}

// constants in shared constants

let g_frame_page = window.parent

let hosted_page_application_handlers = (category,action,relationship,params) => {}



function reponding_alive() {
    let message = {
        "category": FRAME_COMPONENT_SAY_ALIVE,
        "action" : FRAME_COMPONENT_RESPONDING,
        "data" : false
    }
    tell_frame_page(message)
}


function install_frame_page_response() {
    window.addEventListener("message", (event) => {
        let page_source = event.origin
        if ( page_source !== '*' ) {
            // let opener = event.source --- the site page is assumed to be the top level of the interactions
            try {
                let mobj = JSON.parse(event.data)
                let category = mobj.category
                let relationship = mobj.relationship
                let action = mobj.action
                let direction = mobj.direction
                //
                if ( direction === FRAME_PAGE_TO_HOSTED_APP ) {
                    if ( category === FRAME_COMPONENT_SAY_ALIVE ) {
                        if ( action === FRAME_COMPONENT_RESPOND ) {
                            reponding_alive()
                        }
                    } else {
                        let params = mobj.data
                        hosted_page_application_handlers(category,action,relationship,params)
                    }
                }
            } catch (e) {
            }    
        }
    })
}


let g_promise_keeper_user_info = false
let g_promise_resolver_user_info = () => { return false }
let g_promise_reject_user_info = () => { return "NO USER INFO" }

async function human_frame_user_info() {
  g_promise_keeper_user_info = new Prommise((resolve,reject) => {
    g_promise_resolver_user_info = (user_info) => { resolve(user_info) }
  })
  return g_promise_keeper_user_info
}

let injest_personalization = false
let injest_session = false
let application_specific_handlers = (category,action,relationship,params) => {}

let personalization = (post_params) => {}

hosted_page_application_handlers = async (category,action,relationship,params) => {
    switch ( category ) {
        case HOST_APP_PERSONALIZATION : {
            if ( typeof injest_personalization === "function" ) {
                await injest_personalization(action,params)
            }
            break;
        }
        case FRAME_TO_APP_PUBLIC_COMPONENT: {
          if ( action === FRAME_HAS_PERSONALIZATION ) {
            let user_info = params
            if ( typeof g_promise_resolver_user_info === "function" ) {
              g_promise_resolver_user_info(user_info)
            }
          }
          break;
        }
        case FRAME_TO_HOSTED_APP_SESSIONS : {          /// a hosted page that does not start a session.
            if ( typeof injest_session === "function" ) {
                await injest_session(action,params)
            }
            break;
        }
        default: {                  /// any other actions ... could be a login page that fetches a session
            await application_specific_handlers(category,action,relationship,params)
            break;
        }
    }
}


function tell_frame_page(message) {
    if ( !g_frame_page ) return(false)
    let msg = Object.assign({},g_message_template)
    msg.direction = HOSTED_APP_TO_FRAME
    msg.relationship = APP_RELATES_TO_FRAME
    msg.action = message.action
    msg.category = message.category
    msg.data = message.data
    let message_str = JSON.stringify(msg)
    g_frame_page.postMessage(message_str,'*')
    return true
}

function relay_to_pages(message) {
    if ( !g_frame_page ) return(false)
    let msg = Object.assign({},g_message_template)
    msg.direction = HOSTED_APP_TO_ALL
    msg.relationship = APP_RELATES_TO_ALL
    msg.action = message.action
    msg.category = message.category
    msg.data = message.data
    let message_str = JSON.stringify(msg)
    g_frame_page.postMessage(message_str,'*')
}



// END OF HOSTED APP PAGE COM  (ALPHA)




// ---- ---- ---- ---- ---- ----

// WORKER MESSAGES

// operations:  init, chunk, benchmark, storage, session, geolocation

async function wv_human_frame_app_initialization() {
  try {
    let frame_message = {
      "category" : HOSTED_APP_WORKER_OPERATION,
      "action" : HOSTED_APP_INIT_WORKER,
      "data" : message
    }
    tell_frame_page(frame_message)
    let user_info = await human_frame_user_info()
    if ( user_info ) {
        let message = {
        "type" : "init",
        'user' : user_info,
        "session" : g_current_session_name
      }
      g_ownership_worker.postMessage(message) //, no keys sent on initialization... worker sends "keys-up"
    }
  } catch (e) {
    console.log(e)
    return false
  }
  return true
}


async function wv_default_session_readiness() {
  await wv_load_name_list()
  let n = g_session_name_list.length
  g_current_session_name = `safe-record-session-${n}`   // the greatest possible index based name
  //
  await wv_human_frame_app_initialization(user_info)
}



// wv_prep_secure_relay 
//    available for securing the complete wave form comprised of chunks...
//
function wv_prep_secure_relay(data_chunk,section_id) {
  // relay to worker
  let message = {
    'type' : 'chunk',
    'chunk' : data_chunk,               /// send ONE chunk ... 
    'section' : section_id,
    'sess_name' : g_current_session_name
  }
  g_ownership_worker.postMessage(message) // ,[data_chunk]
}


// wv_secure 
//    available for securing the complete wave form comprised of chunks...
//
function wv_secure(op,audioBlob,id_param) {  // called for these states of processing: edit-update, end-recording
  // relay to worker
  let message = {
    'type' : 'benchmark',
    'blob' : audioBlob,
    'op' : op,
    'blob_id' : id_param
  }
  g_ownership_worker.postMessage(message) // ,[data_chunk]
}


// wv_secure_total_session
//    called for edit operations and switching between sessions...
//    This secures a named sessions which may include a number of parts each comprising a number of chunks.... 
//
async function wv_secure_total_session(sess_name) {
  try {
    let sessionObj = await get_audio_data(sess_name)
    let complete_name = sess_name + "-complete"
    await make_complete_session_record(complete_name,sessionObj,g_preferred_download_format)
    let message = {
      'type' : 'storage',
      'sess_id' : complete_name,
      'ext' : ext_from_download_format(g_preferred_download_format)
    }
    //
    let frame_message = {
      "category" : HOSTED_APP_WORKER_OPERATION,
      "action" : HOSTED_APP_DATABASE_STORE,
      "data" : message
    }
    tell_frame_page(frame_message)
    //
  } catch (e) {
  }
}


//  wv_change_session_name
//    a high level session editing operation... tell worker what session is being edited
//
function wv_change_session_name() {  // tell worker what session is being edited
  let message = {
    'type' : 'session',
    'sess_name' : g_current_session_name
  }
  let frame_message = {
    "category" : HOSTED_APP_WORKER_OPERATION,
    "action" : HOSTED_APP_PROPERTIES,
    "data" : message
  }
  tell_frame_page(frame_message)
}

//
//  wv_update_geo_location 
//  this is applied to recording a part.  Each part may have a location at which it is recorded.
//  This information is passed on to the work. The interface will request permission from the user.
//
function wv_update_geo_location(location) {
  let message = {
    'type' : 'geolocation',
    'geo_location' : location
  }
  let frame_message = {
    "category" : HOSTED_APP_WORKER_OPERATION,
    "action" : HOSTED_APP_PROPERTIES,
    "data" : message
  }
  tell_frame_page(frame_message)
}


//
//  wv_update_geo_location 
//  this is applied to recording a part.  Each part may have a location at which it is recorded.
//  This information is passed on to the work. The interface will request permission from the user.
//
function wv_verify_ownership(location,sess_name) {
  let complete_name = sess_name + "-complete"
  let message = {
    'type' : 'verify',
    'sess_id' : complete_name
  }
  let frame_message = {
    "category" : HOSTED_APP_WORKER_OPERATION,
    "action" : HOSTED_APP_DATA_VERIFY,
    "data" : message
  }
  tell_frame_page(frame_message)
}



// <- end of ... WORKER MESSAGES




var BASE64_MARKER = ';base64,';
//
function convertDataURIToBinary(dataURI) {
  var base64Index = dataURI.indexOf(BASE64_MARKER) + BASE64_MARKER.length;
  var base64 = dataURI.substring(base64Index);
  var raw = window.atob(base64);
  var rawLength = raw.length;
  var array = new Uint8Array(new ArrayBuffer(rawLength));

  for(i = 0; i < rawLength; i++) {
    array[i] = raw.charCodeAt(i);
  }
  return array;
}


// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
// OWNERSHIP WORKER!!!
let g_ownership_worker = new Worker(REQ_WORKER_CODE)

g_ownership_worker.onmessage = async (msg) => {
  //
  switch ( msg.data.type ) {
    case 'status' : {
      worker_status_view(msg.data.message)
      break;
    }
    case 'info-ws' : {
      msg.category = HOSTED_APP_WORKER_OPERATION
      msg.action = HOSTED_APP_DATABASE_STORE
      tell_frame_page(msg)
      break;
    }
    case 'op-complete' : {
      if ( msg.transition === 'chunk-final' || msg.transition ===  'edit-update' ) {
        msg.category = FRAME_ACTION_FROM_PUBLISHER
        msg.action = HOSTED_APP_FILE_OPERATION
        let sessionObj = await get_audio_data(msg.session)
        msg.data = {
          "op" : "store",
          "audio_data" : create_asset_meta(sessionObj)
        }
        tell_frame_page(msg)      /// 
      }
      break;
    }
    case 'keys-up' : {
      msg.category = HOSTED_APP_WORKER_OPERATION
      msg.action = HOSTED_APP_DATABASE_STORE
      tell_frame_page(msg)
    }
    default: {
      // ----
    }
  }
}



// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
// TOOLS -- UTILITIES
//>--
function get_client_device_name() {
    let oscpu = navigator.oscpu
    let ua = navigator.userAgent
    let user_given_machine_name = g_current_session_machine_name
    //
    let b = `${oscpu}-${ua}-${user_given_machine_name}`
    b = encodeURIComponent(b.trim())
    return(b)
}
//--<


function uuidv4() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}


function ext_from_download_format(download_format) {
  if ( download_format === 'audio/wave' ) {
    return("wav")
  }
  if ( download_format === 'audio/ogg' ) {
    return("ogg")
  }
  if ( download_format === 'audio/mpeg' ) {
    return("mp3")
  }
}


function blobToBase64(blob) {
  return new Promise(resolve => {
    const reader = new FileReader();
    reader.readAsDataURL(blob);
    reader.onloadend = () => {
      resolve(reader.result);
    };
  });
}


// ----
function make_audio_blob(channel_data_list) {
  let d1 = channel_data_list[0]
  let d2 = channel_data_list[1]
  let wb = new WaveBlob()
  wb.record(d1)
  wb.record(d2)
  //
  let blob = wb.toBlob('audio/wave')
  //
  return(blob)
}



async function concat_all_to_array(list_of_sections) {
  let start = list_of_sections.unshift()
  while ( list_of_sections.length ) {
    let next_sect = list_of_sections.unshift()
    start = start.concat(next_sect)
  }
  return(start)
}



// https://stackoverflow.com/questions/33702838/how-to-append-bytes-multi-bytes-and-buffer-to-arraybuffer-in-javascript
function concatTypedArrays(a, b) { // a, b TypedArray of same type
  var c = new (a.constructor)(a.length + b.length);
  c.set(a, 0);
  c.set(b, a.length);
  return c;
}



function lst_remove(list,index) {
    list.splice(index,1)
  }

  function lst_insert_before(list,el,index) {
    list.splice(index,0,el)
  }




// ------ ------ ------ ------ ------ ------ ------ ------ ------ ------ ------ ------ ------

var g_current_session_machine_name = "tester"



/**
 * AppAudioRecorder
 *
 *  Manage the use of the media recorder 
 */

class AppAudioRecorder {
  //  //  //
  constructor(stream,chunck_interval) {
    //
    this.audioChunks = [];
    let mediaRecorder = new MediaRecorder(stream);

    // send a frame to ownership
 
    this.mediaRecorder = mediaRecorder
    this.audio_instance = null
    this.section_id = 0
    //
    this.chunk_interval = chunck_interval
    //
    mediaRecorder.addEventListener('dataavailable', event => {    // DATA AVAILABLE
      this.data_handler(event)
    });

    mediaRecorder.addEventListener('stop',  event => {
      this.stop_handler(event)
    });
  }
  

  //  data_handler
  //
  data_handler(data) {      /// called at the interval (see setup in constructore)
    let chunk = event.data
    this.audioChunks.push(chunk);
    wv_prep_secure_relay(chunk,this.section_id)       // pass to thread (thread will do calculations)
  }


  //  start
  //
  start() {                // wrap the recorder start method and make sure configuration parameters are stored
    this.section_id = 'ER' + uuidv4() // use ER to signify End(Edit) Recording and be different than other randoms
    //
    this.audioChunks = []
    if ( typeof this.chunk_interval === 'number' ) {
      this.mediaRecorder.start(this.chunk_interval);
    } else {
      this.mediaRecorder.start();
    }
  }

  //  stop_handler
  //
  stop_handler(event) {
    this.audio_results()
  }

  // stop
  //
  stop() {
    this.mediaRecorder.stop();
  }

  // audio_results
  // Called when recording stops.. This makes the first record of a collection of audio chunks
  // A section ID is produced. The section ID will be used later when the user decideds to save 
  // the section... However, the section hash will be sent on to the server. (note: section v.s. session)
  async audio_results() {
    let audioBlob = new Blob(this.audioChunks);
    let audioUrl = URL.createObjectURL(audioBlob);
    this.audioBlob = audioBlob
    this.audio_instance = new Audio(audioUrl);
    await wv_backup_audio_chunks_for_verification(this.section_id,this.audioChunks)
    wv_secure('end-recording',audioBlob,this.section_id)
  }

  // add_current_data
  // Called when the user decides to save the audio as part of the named session
  // At this point, there is a section_id. It is used to make sure the indexedDB storage 
  // maps to the blob
  add_current_data() {
    if ( this.audioBlob ) {
      add_audio_data(this.audioBlob,this.section_id)
    }
  }

  delete_last_recorderd_audio() {
    this.audio_instance = null
    this.audioBlob = null
  }

  play() {
    if ( this.audio_instance ) {
      this.audio_instance.play()
    }
  }

}
// END OF CLASS AUDIO RECORDER


  ////////////////

class WaveBlob {
  constructor() {
    this.recLength = 0
    this.recBuffer = []
    this.recordSampleRate = g_audioContext.sampleRate
  }

  clear() {
    this.recLength = 0;
    this.recBuffer = [];
  }

  record(inputBuffer) {
    this.recBuffer.push(inputBuffer);
    this.recLength += inputBuffer.length;
  }

  toBlob(ctyp) {
    var mergedBuffers = this.interleaveLeftAndRight(this.recBuffer);
    var encodedWav = this.encodeWAV(mergedBuffers);
    var audioBlob = new Blob([encodedWav], {type: ctyp});
    return(audioBlob);
  }

  mergeBuffers(array_of_buffers, recLength) {
    let result = new Float32Array(recLength);
    let offset = 0;
    let n = array_of_buffers.length
    for ( let i = 0; i < n; i++ ) {
      result.set(array_of_buffers[i], offset);
      offset += array_of_buffers[i].length;
    }
    return result;
  }

  interleaveLeftAndRight(bufferList) {
    let left = bufferList[0]
    let right = bufferList[1]
    let totalLength = left.length + right.length;
    let data = new Float32Array(totalLength);
    let n = left.length
    for ( let i = 0; i < n; i++ ) {
      let k = i * 2;
      data[k] = left[i];
      data[k + 1] = right[i];
    }
    return(data)
  }


  // mutate output Int16
  floatTo16BitPCM(output, offset, input) {
    let n =  input.length
    for ( let i = 0; i < n; (i++, offset += 2) ) {
      let s = Math.max(-1, Math.min(1, input[i]));
      output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    }
  }

  writeString(view, offset, string) {
    for (var i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  }

  encodeWAV(samples) {
    const WAV_HEAD_SIZE = 44
    let channels = 2
    let dat_len = samples.length * 2
    let buffer = new ArrayBuffer((dat_len * 2) + WAV_HEAD_SIZE)

    let view = new DataView(buffer);

    let recordSampleRate = this.recordSampleRate
    // RIFF chunk descriptor/identifier
    this.writeString(view, 0, 'RIFF')
    // RIFF chunk length
    view.setUint32(4, WAV_HEAD_SIZE + (dat_len * 2), true)  // 32
    // RIFF type
    this.writeString(view, 8, 'WAVE');
    // format chunk identifier
    // FMT sub-chunk
    this.writeString(view, 12, 'fmt ');
    // format chunk length
    view.setUint32(16, 16, true);
    // sample format (raw)
    view.setUint16(20, 1, true);
     // stereo (2 channels)
    view.setUint16(22, channels, true);
    // sample rate
    view.setUint32(24, recordSampleRate, true);
    // byte rate (sample rate * block align)
    view.setUint32(28, recordSampleRate * 2, true);
    // block align (channel count * bytes per sample)
    view.setUint16(32, (channels * 2), true);
    // bits per sample
    view.setUint16(34, 16, true);
    // data sub-chunk
    // data chunk identifier
    this.writeString(view, 36, 'data');
    // data chunk length
    view.setUint32(40, samples.length * 2, true);
    this.floatTo16BitPCM(view, 44, samples);


    return view;
  }

}



//  ----   AUDIO TOOLS

function wv_concat_sections(raw_sections) {
  let n = raw_sections.length
  let result_buffer = raw_sections.shift()
  while ( raw_sections.length ) {
    let next_buffer = raw_sections.shift()
    result_buffer = concatTypedArrays(result_buffer, next_buffer)
  }
  return result_buffer
}

async function make_complete_session_record(sess_name_cmplt,sessionObj,contentType) {
  // make a file storage format
  let raw_sections = []
  let mapkys = null
  if ( sessionObj.edit_order ) {
    mapkys = sessionObj.edit_order
    mapkys = mapkys.map(bid => {
      if ( bid.indexOf('audio-div-') === 0 ) {
        return bid.replace('audio-div-','')
      } else {
        return bid
      }
    })
  } else {
    mapkys = Object.keys(sessionObj.data)
  }
  //
  let n = mapkys.length
  for ( let i = 0; i < n; i++ ) {
    let wave_name = mapkys[i]
    let raw_wave = await get_wave_data(wave_name)
    raw_sections.push(raw_wave)
  }
  //
  let total_sections = wv_concat_sections(raw_sections)
  let audioBlob = make_audio_blob([total_sections,total_sections])
  //
  try {
    await store_audio_key(sess_name_cmplt,audioBlob)
  } catch (e) {
    console.log(e)
  }
  //
}


// AUDIO MODAL
const dmodal = g_audio_download_modal
const cancel_dmodal = document.getElementById('wave-download-cancel');

dmodal.addEventListener('cancel', () => {
  //modal.close('cancelled');
});

// close when clicking on backdrop
dmodal.addEventListener('click', (event) => {
  if (event.target === dmodal) {
    dmodal.close('cancelled');
  }
});

// 
cancel_dmodal.addEventListener('click', () => {
  dmodal.close('cancelled');
});


//
async function store_audio_key(app_audio_key,audioBlob) {
  if ( g_audio_db === null ) {
    console.log("db not initialized :: update_audio_data")
    return;
  }
  try {
    let storable = await blobToBase64(audioBlob)
    let storeObj = {
        'name' : app_audio_key,
        'blob' : storable,
        'lastModified' : Date.now(),
        'type' : 'audio/x-wav',
        'size' : audioBlob.size(),
        'pub_verification_key' : g_pub_verification_key
      }
    await g_audio_db.store_completion(storeObj)
  } catch (e) {
  }
}

// //
async function get_audio_key(app_audio_key) {
  if ( g_audio_db === null ) {
    console.log("db not initialized :: update_audio_data")
    return;
  }
  let storeObj = await g_audio_db.get_completion()
  return storeObj
}

//
async function remove_complete_if_exists(app_audio_key) {
  if ( g_audio_db === null ) {
    console.log("db not initialized :: update_audio_data")
    return;
  }
  //
  await g_audio_db.remove_completion(app_audio_key)
}


//  ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//   AUDIO_SESSION_STORE  ----


function update_audio_data(section_id,data_list,op_parameters) {
  //
  if ( g_audio_db === null ) {
    console.log("db not initialized :: update_audio_data")
    return;
  }
  //
  let audioBlob = make_audio_blob(data_list)
  g_audio_db.update_data(audioBlob,section_id,op_parameters)
  //
}



// assuming there is an array that has been collected
// each element will correspond to a resulting hash
// The hashes are sent to the server and can be reconstructed later
// but only if the chunk array is still available in its original form
async function wv_backup_audio_chunks_for_verification(part_id,audioChunksArray) {
  if ( g_audio_db === null ) {
    console.log("db not initialized :: wv_backup_audio_chunks_for_verification")
    return;
  }
  //
  let converted_chunks = []
  let n = audioChunksArray.length
  for ( let i = 0; i < n; i++ ) {
    let chunk = audioChunksArray[i]
    let storable = await blobToBase64(chunk)
    converted_chunks.push(storable)
  }
  // 
  let pre_update = async (part_id,sessionObj) => {
    if ( sessionObj ) {
      sessionObj.original_chunks[part_id] = converted_chunks
    }
  }
  //
  let post_update = async (part_id,session_name,sessionObj) => {
    await wv_secure_total_session(g_current_session_name)
  }
  //
  await g_audio_db.update_data_ops(part_id,pre_update,post_update)
  //
}



async function add_audio_data(audioBlob,section_id) {
  if ( g_audio_db === null ) {
    console.log("db not initialized :: add_audio_data")
    return;
  }
  await g_audio_db.add_data(audioBlob,section_id)
}


async function get_audio_data(sess_name) {
  if ( g_audio_db === null ) {
    console.log("db not initialized :: get_audio_data")
    return;
  }
  try {
    let data = await g_audio_db.get_session(sess_name)
    return data
  } catch(e) {}
  return false
}


async function remove_audio_data(audio_key) {
  if ( g_audio_db === null ) {
    console.log("db not initialized :: remove_audio_data")
    return;
  }
  await g_audio_db.remove_file(audio_key)
}

function is_new_name(name) {
  if ( g_session_name_list.indexOf(name) >= 0 ) return(false)
  return(true)
}

async function wv_load_name_list() {
  if ( g_audio_db === null ) {
    console.log("db not initialized :: remove_audio_data")
    return;
  }
  //
  g_session_name_list = await g_audio_db.get_file_entries()
  update_session_name_selections(g_audio_db.session_name,g_session_name_list)
  //
}


function update_session_name_selections(sess_name,name_list) {
  if ( sess_name === undefined ) return;
  //
  let session_options = name_list.map(name => {
    let el_html = `<option value='${name}'>${name}</option>`
    return(el_html)
  })

  let no_option = `<option value="none">no selection</option>`
  session_options.unshift(no_option)
  let options = session_options.join('\n')
  let sessNameSel = document.getElementById('sess-names')
  if ( sessNameSel ) {
    sessNameSel.innerHTML = options
    sessNameSel.value = sess_name
  }
  let sess_name_el = document.getElementById('show-session-name')
  if ( sess_name_el ) sess_name_el.innerHTML = (sess_name === 'none') ? '<span style="color:orange">select or create a session</span>' : sess_name
}

function warn(str) {
  //
}

async function add_in_new_session(name) {
  let sess_name_el = document.getElementById('show-session-name')
  if ( sess_name_el && name ) {
    g_current_session_name = name
    g_session_name_list.push(name)
    sess_name_el.innerHTML = name
    g_recordButton.removeAttribute('disabled');     // Turn on recording 
    //
    let propagate_session = (sessionObj) => {
      // sessionObj.name  === g_current_session_name // session of this name is going into the DB
      wv_change_session_name()      // uses g_current_session_name
    }
    g_audio_db.add_empty_session(name,propagate_session)              // creating a new session
    //
    clear_play_list()
    let sess_op_el = document.getElementById('delete-session')
    if ( sess_op_el ) {
      sess_op_el.style.visibility = "visible"
    }

    // Put the new session name into the list
    await update_session_name_selections(g_current_session_name,g_session_name_list)
  }
}

function ask_user_session() {
  let proceed = confirm("Start a new session?")
  if ( proceed ) {
    let name = prompt("Name this session:", "new session");
    let new_name = is_new_name(name)
    if ( new_name ) {
      add_in_new_session(name)
    } else {
      warn("Session already exists. Do you want to edit it?")
    }
  }
}


async function choose_edit_user_session(name) {
  //
  if ( g_current_session_name !== 'none' ) {
    await wv_secure_total_session(g_current_session_name)
  }
  //
  g_save_up_audio_elements = {}
  //
  if ( name === 'none' ) {
    let sess_name_el = document.getElementById('show-session-name')
    if ( sess_name_el ) {
      g_current_session_name = 'none'
      sess_name_el.innerHTML = '<span style="color:orange">select or create a session</span>'

      g_recordButton.setAttribute('disabled', true);
      g_stopButton.setAttribute('disabled', true);
      g_playButton.setAttribute('disabled', true);
      g_saveButton.setAttribute('disabled', true);
      g_deleteButton.setAttribute('disabled', true);
      clear_play_list()
      let sess_op_el = null
      sess_op_el = document.getElementById('send-session')
      if ( sess_op_el ) {
        sess_op_el.style.visibility = "hidden"
      }
      sess_op_el = document.getElementById('delete-session')
      if ( sess_op_el ) {
        sess_op_el.style.visibility = "hidden"
      }
    }
  } else {
    let sess_name_el = document.getElementById('show-session-name')
    if ( sess_name_el ) {
      g_current_session_name = name
      sess_name_el.innerHTML = name
      g_recordButton.removeAttribute('disabled');
      g_stopButton.setAttribute('disabled', true);
      g_playButton.setAttribute('disabled', true);
      g_saveButton.setAttribute('disabled', true);
      g_deleteButton.setAttribute('disabled', true);
      //
      clear_play_list()
      let sess_op_el = null
      sess_op_el = document.getElementById('send-session')
      if ( sess_op_el ) {
        sess_op_el.style.visibility = "inherit"
      }
      sess_op_el = document.getElementById('delete-session')
      if ( sess_op_el ) {
        sess_op_el.style.visibility = "inherit"
      }
      await populate_play_list(g_current_session_name)
    }
  }
  wv_change_session_name()
}

function edit_user_session(event) {
  let sessNameSel = document.getElementById('sess-names')
  choose_edit_user_session(sessNameSel.value)
}


async function delete_session() {
  if ( g_audio_db === null ) {
    console.log("db not initialized :: remove_audio_data")
    return;
  }
  await g_audio_db.delete_session()
}


async function wv_reset_audio_sections_order(map_ids) {
  if ( g_current_session_name !== 'none ') {
      //
      if ( g_audio_db === null ) {
        console.log("db not initialized :: delete_session")
        return;
      }
      // 
      let pre_update = async (part_id,sessionObj) => {
        if ( sessionObj ) {
          sessionObj.edit_order = map_ids
        }
      }
      //
      let post_update = async (part_id,session_name,sessionObj) => {
        await wv_secure_total_session(g_current_session_name)
      }
      //
      await g_audio_db.update_data_ops(part_id,pre_update,post_update)
      // 
  }
}


// RECORDER
async function wv_init_recorder() {
  const stream = await navigator.mediaDevices.getUserMedia({ 'audio': true });
  g_app_recoder = new AppAudioRecorder(stream,MILSEC_CHUNK_INTERVAL)
}

//
const sleep = time => new Promise(resolve => setTimeout(resolve, time));

function wv_initialize_global_buttons() {
  //
  g_recordButton.setAttribute('disabled', true);
  g_stopButton.setAttribute('disabled', true);
  g_playButton.setAttribute('disabled', true);
  g_saveButton.setAttribute('disabled', true);
  g_deleteButton.setAttribute('disabled', true);
  let sess_op_el = null
  sess_op_el = document.getElementById('send-session')
  if ( sess_op_el ) {
    sess_op_el.style.visibility = "hidden"
  }
  sess_op_el = document.getElementById('delete-session')
  if ( sess_op_el ) {
    sess_op_el.style.visibility = "hidden"
  }

  // RECORD
  g_recordButton.addEventListener('click', async () => {
    stop_geo_update()
    g_recordButton.setAttribute('disabled', true);
    g_stopButton.removeAttribute('disabled');
    g_playButton.setAttribute('disabled', true);
    g_saveButton.setAttribute('disabled', true);
    g_deleteButton.setAttribute('disabled', true);
    g_app_recoder.start();
  });

  // STOP RECORD
  g_stopButton.addEventListener('click', async () => {
    restart_geo_update()
    g_recordButton.removeAttribute('disabled');
    g_stopButton.setAttribute('disabled', true);
    g_playButton.removeAttribute('disabled');
    g_saveButton.removeAttribute('disabled');
    g_deleteButton.removeAttribute('disabled');
    g_app_recoder.stop();
  });

  // PLAY
  g_playButton.addEventListener('click', () => {
    stop_geo_update()
    g_app_recoder.play();
  });

  // DELETE
  g_deleteButton.addEventListener('click', async () => {
    g_saveButton.setAttribute('disabled', true);
    g_playButton.setAttribute('disabled', true);
    g_deleteButton.setAttribute('disabled', true);
    g_app_recoder.delete_last_recorderd_audio()
  })

  // SAVE
  g_saveButton.addEventListener('click', () => {
    g_app_recoder.add_current_data()
    let sess_op_el = document.getElementById('send-session')
    if ( sess_op_el ) {
      sess_op_el.style.visibility = "visible"
    }
  });

}


  function wv_rect_vertical_intersect_size(r1,r2) {
    //
    let y1_top = r1.top
    let y1_bot = r1.bottom
    //
    let y2_top = r2.top
    let y2_bot = r2.bottom
    if ( (y2_bot <= y1_top) || (y1_bot <= y2_top) ) return 0
    //
    if ( y1_top < y2_top ) {
      return(y1_bot - y2_top)  // increasing downward
    } else {
      return(y2_bot - y1_top)  // increasing downward
    }
  }

  g_audio_play_list_order = []
  function getIntersectedElement(rect) {
    if ( g_audio_play_list_order.length > 1 ) {
      let max_area = 0
      let area_owner = null
      g_audio_play_list_order.forEach(divEl => {
        let check_rect = divEl.getBoundingClientRect()
        let intersect_size = wv_rect_vertical_intersect_size(rect,check_rect)
        if ( intersect_size > max_area ) {
          max_area = intersect_size
          area_owner = divEl
        }
      })
      return area_owner
    }
    return false
  }


  function wv_reposition(srcEl,dstEl) {
    let i = 0;
    let n = g_audio_play_list_order.length
    let from = -1
    let to = -1
    while ( i < n ) {
      let tst_el = g_audio_play_list_order[i]
      if ( tst_el == srcEl ) from = i
      if ( tst_el == dstEl ) to = i
      if ( (from != -1) && (to != -1) ) break
      i++
    }
    if ( ( from != -1 )&& ( to != -1 ) && ( from !== to ) ) {
      // not a swap...
      // swap the two elements according to their position in the childNodes of the parent
      let p_node = srcEl.parentNode
      if ( p_node ) {
        if ( from > to ) {
          lst_remove(g_audio_play_list_order,from)
          lst_insert_before(g_audio_play_list_order,srcEl,to)
          //
          p_node.insertBefore(srcEl,dstEl)
        } else if ( from < to ) {
          lst_remove(g_audio_play_list_order,from)
          lst_insert_before(g_audio_play_list_order,srcEl,to)
          //    
          let dst_follow_node = dstEl.nextSibling
          if ( dst_follow_node ) {
            p_node.insertBefore(srcEl,dst_follow_node)
          } else {
            p_node.appendChild(srcEl)
          } 
        }
      }
      //
      if ( from !== to ) {
        let map_ids = g_audio_play_list_order.map(divEl => {
          let id = divEl.id
          id = id.replace('audio-div-','')
          return(id)
        })
        //
        wv_reset_audio_sections_order(map_ids)
      }
      //
    }

  }



  function wv_move_html_element(elem,track_source) {
    //
    if ( elem._tracker ) {
      elem.removeEventListener('mousemove',elem._tracker)
    }
    elem._tracker = (ev) => {
      let mover = elem;
      let y = ev.clientY;
      let delta_y = mover._app_mouse_y - ev.clientY;
      mover._app_mouse_y = ev.clientY;
      // set the element's new position:
      let new_y = (mover.offsetTop - delta_y)
      // lower bound
      if ( new_y > 8 ) mover.style.top = new_y + "px";
    }
    window.addEventListener('mousemove',elem._tracker)
    track_source.addEventListener('mousemove',elem._tracker)
    //
    elem._releaser = (ev) => {
      track_source.removeEventListener('mousemove',elem._tracker)
      window.removeEventListener('mousemove',elem._tracker)
      window.removeEventListener('mouseup',elem._releaser)
      elem._releaser = null
      elem._tracker = null
      //
      let divEl = elem._source
      divEl._ghost = false
      elem._source = false
      divEl._moving_audio_box = 0
      divEl._dragging = false
      //
      let y = ev.clientY;
      let rect = elem.getBoundingClientRect();
      elem.style.visibility = 'hidden'
      elem.style.display = 'none'
      //
      let overEl = getIntersectedElement(rect)
      if ( overEl && (overEl !== track_source) ) {
        let ydiff = elem._app_mouse_y - y;
        wv_reposition(divEl,overEl)
      }
      //
    }
    window.addEventListener('mouseup',elem._releaser)
  }

  
  function add_audio_playback_box_responsiveness(divEl) {
    //
    g_audio_play_list_order.push(divEl)
    //
    divEl._wait_to_drag = null
    //
    divEl.addEventListener('mousedown',(ev) => {
      if ( divEl !== ev.target ) return;
      divEl._wait_to_drag = setTimeout(() => {
        clearTimeout(divEl._wait_to_drag)
        divEl._wait_to_drag = null
        //
        let outliner = document.getElementById('audioBoxGhost')
        outliner.style.position = "absolute"
        outliner.style.zIndex = 1000
        let d_rect = divEl.getBoundingClientRect()
        outliner.style.top = d_rect.top + "px"
        outliner.style.left = d_rect.left + "px"
        outliner.style.width = d_rect.width + "px"
        outliner.style.height = d_rect.height + "px"
        outliner._source = divEl
        divEl._ghost = outliner
        outliner.style.display = 'block'
        outliner.style.visibility = "inherit"
        let y = ev.clientY;
        outliner._app_mouse_y = y
        //---
        wv_move_html_element(outliner,divEl)
        //--
      },350)
    })
    //
    let quic_hit = (ev) => {
      if ( divEl._wait_to_drag !== null ) {
        clearTimeout(divEl._wait_to_drag)
        divEl._wait_to_drag = null
      }
      window.removeEventListener('mouseup',quic_hit)
    }
    divEl.addEventListener('mouseup',quic_hit)
  }



function update_audio_element(audio_el_url,index,audioBlob) {
  if ( index === undefined ) return
  else {
    let audioElement = document.getElementById(`audio-player-${index}`)
    if ( audioElement ) {
      audioElement.src = audio_el_url;
      audioElement.setAttribute('data-audio-filename', audio_el_url);
      audioElement.pause()
      audioElement.load()
      let divEl = document.getElementById(`audio-div-${index}`)
      if ( divEl ) {
        divEl._ref_audio_data = audioBlob
      }
    }
  }
}


function add_audio_element(audio_el_url,index,audioBlob,section_id) {
  if ( index === undefined ) index = uuidv4()
  let audioElement = document.createElement('audio');
  audioElement.src = audio_el_url;
  audioElement.setAttribute('data-audio-filename', audio_el_url);
  audioElement.setAttribute('controls', true);
  audioElement.className = "audio-playback"
  audioElement.id = `audio-player-${index}`
  g_save_up_audio_elements[index] = audioElement
  // ontimeupdate
  // add a playback track
  let divEl = document.createElement('div')
  divEl.id = `audio-div-${index}`
  divEl._ref_audio_data = audioBlob
  divEl.className = "playback-div"
  add_audio_playback_box_responsiveness(divEl)
  let checkEl = document.createElement('input')
  checkEl.type = "checkbox";
  checkEl.name = `audioSections`;
  checkEl.className = "check_audio_element"
  checkEl.value = "";
  checkEl.id = `audio-cbox-${index}`;
  divEl.appendChild(checkEl)
  divEl.appendChild(audioElement)
  // add the element
  savedAudioMessagesContainer.appendChild(divEl);
}


function clear_play_list() {
    g_audio_play_list_order = []
  if ( savedAudioMessagesContainer ) {
    let wave_keys = Object.keys(g_wave_open_editors)
    wave_keys.forEach( wave_name => { remove_wave_editor(wave_name) } )
    savedAudioMessagesContainer.innerHTML = ""
  }
}


async function populate_play_list(sess_name) {
  //
  if ( g_audio_db === null ) {
    console.log("db not initialized :: populate_play_list")
    return;
  }
  //
  let sessionObj = await g_audio_db.get_session(sess_name)
  //
  let blob_map = sessionObj.data
  let ordering = sessionObj.edit_order
  ordering = ordering.map(bid => {
    if ( bid.indexOf('audio-div-') === 0 ) {
      return bid.replace('audio-div-','')
    } else {
      return bid
    }
  })
  ordering.forEach(blob_id => {
    let audioBlob = blob_map[blob_id]
    let blob_url = URL.createObjectURL(audioBlob)
    add_audio_element(blob_url,blob_id,audioBlob)
  })
  //
};



// WAVE EDITOR FUNCIONALITY

function draw_h_line(ctx, x, y, width, thick, color) {
  ctx.lineWidth = thick; // how thick the line is
  ctx.strokeStyle = color; // what color our line is
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo((x + width), y);
  ctx.stroke();
}

function draw_v_line(ctx, x, y, height, thick, color) {
  ctx.lineWidth = thick; // how thick the line is
  ctx.strokeStyle = color; // what color our line is
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x, (y + height));
  ctx.stroke();
}


function draw_short_line(ctx, x0, y0, x1, y1, thick, color) {
  ctx.lineWidth = thick; // how thick the line is
  ctx.strokeStyle = color; // what color our line is
  ctx.beginPath();
  ctx.moveTo(x0, y0);
  ctx.lineTo(x1, y1);
  ctx.stroke();
}

function draw_line_chart(ctx,x0,y0,data,offset,n,thick, color) {
  ctx.lineWidth = thick; // how thick the line is
  ctx.strokeStyle = color; // what color our line is
  ctx.beginPath();
  ctx.closePath();
  //
  let x = x0
  ctx.moveTo(x,y0);
  for ( let i = 0; i < n; (i++,x++) ) {
    ctx.lineTo(x, -data[i+offset]);    // canvas is upside down
  }
  ctx.stroke();
}

function draw_seconds(ctx,x,y,color,txt) {
  ctx.lineWidth = 2; // how thick the line is
  ctx.strokeStyle = color; // what color our line is
  ctx.font = '22px serif';
  let secs_txt = txt + " secs"
  ctx.fillText(secs_txt, x, y);
}

function wv_clear_selection(player_info) {
  if ( player_info.save_selection.startX !== undefined ) {
    let ctx = player_info.graph
    let saved_comp = ctx.globalCompositeOperation 
    let rect = player_info.save_selection
    ctx.globalCompositeOperation = 'xor'
    ctx.fillStyle = "#000000";
    ctx.fillRect(rect.startX, rect.startY, rect.w, rect.h);
    ctx.globalCompositeOperation = saved_comp
    player_info.save_selection = {}
  }
}


const getBlobData = (wave_name) => {
  let player_div = document.getElementById(`audio-div-${wave_name}`)
  let audio_blob = player_div._ref_audio_data
  return audio_blob
}

async function get_wave_data(wave_name,channels,blob_fetcher) {  // sample_ratio up or down sample
  let audio_blob = blob_fetcher ? blob_fetcher(wave_name) : getBlobData(wave_name)
  const audioContext = new AudioContext();
  // audio blob contains blob data
  let arrayBuffer = await audio_blob.arrayBuffer();
  let audioBuffer = await audioContext.decodeAudioData(arrayBuffer)
  if ( (channels === undefined) || (channels === 1) ) {
    let rawData = audioBuffer.getChannelData(0);
    return rawData      
  } else {
    let rawData = []
    let nchan = Math.min(audioBuffer.numberOfChannels,channels)
    for ( let i = 0; i < nchan; i++ ) {
      rawData.push(audioBuffer.getChannelData(i))
    }
    return(rawData)
  }
}

function get_wave_seconds(wave_name) {  // use the element
  let audioElement = g_save_up_audio_elements[wave_name]
  if ( audioElement ) {
    return(`${audioElement.duration}`)
  }
  return 'NaN'
}

//
// spp -- samples per pixel
function reduceAudioPeak(data, spp, scroll, width) {
  if ( spp <= 1 ) return(data)
  //
  let drawData = new Array(width);
  let startSample = scroll * spp; 
  // For each pixel in draw area
  for ( let i = 0; i < width; i++ ) {
      let min = 0; // minimum value in sample range
      let max = 0; // maximum value in sample range
      let k = startSample + (i * spp);

      // Iterate over the sample range for this pixel (spp) 
      // and find the min and max values. 
      let avg = 0.0
      for ( let j = 0; j < spp; (j++,k++) ) {
         if ( k < data.length ) {
             let val = data[k];
             avg += val
         }
      }
      avg = avg/spp

      drawData[i] = avg;
  }
  return drawData;
}

  
function draw_wave(data,ctx,W,h,dataSecs) {
  // Set up the canvas
  ctx.clearRect(0,-h,W,(2*h))
  draw_h_line(ctx, 0, 0, W, 2, '#009')
  let offset = ZERO_AXIS_OFFSET
  draw_v_line(ctx, offset, -h, (2*h), 2, '#9999A9')
  //
  // size data to visible
  let n_pixels = (W - offset)
  let samples_per_pixel = Math.ceil(data.length/n_pixels)
  let dmax = Math.max(...data)
  let section_start = 0 //data.indexOf(dmax) - 200
  let dmin = Math.abs(Math.min(...data))
  dmax = Math.max(dmin,dmax)
  let factor = WAVE_DISPLAY_MAX/dmin
  data = data.map(datum => datum*factor)
  let draw_data = reduceAudioPeak(data, samples_per_pixel, 0, n_pixels)
  //
  draw_line_chart(ctx, 10, 0, draw_data, section_start, n_pixels, 1, '#000')
  //
  let fsecs = parseFloat(dataSecs)
  fsecs = fsecs.toFixed(3)
  //
  if ( dataSecs ) draw_seconds(ctx,15,h,'#000',`${fsecs}`)
}


function update_play_marker(ctx,play_info,percent) {
  let last_tick = play_info.where_ticker
  let offset = ZERO_AXIS_OFFSET
  let width = play_info.width - offset
  let where_now = Math.round(width*percent) + offset
  play_info.where_ticker = where_now
  //
  let saved_comp = ctx.globalCompositeOperation
  ctx.globalCompositeOperation = 'xor'
  ctx.fillStyle = "#000000";
  ctx.fillRect(last_tick,-play_info.height,2,(2*play_info.height));
  ctx.fillRect(where_now,-play_info.height,2,(2*play_info.height));
  ctx.globalCompositeOperation = saved_comp
}


// either from stack exchange or from MSDN doc..
function isElementVisible(el,topOffset,leftOffset) {
  let rect     = el.getBoundingClientRect(),
      vWidth   = window.innerWidth || document.documentElement.clientWidth,
      vHeight  = window.innerHeight || document.documentElement.clientHeight,
      efp      = function (x, y) { return document.elementFromPoint(x, y) };     

  // Return false if it's not in the viewport
  if (rect.right < 0 || rect.bottom < 0 
          || rect.left > vWidth || rect.top > vHeight)
      return false;

  // Return true if any of its four corners are visible
  let rect_top = rect.top + (topOffset ? topOffset : 0)
  let rect_left = rect.left + (leftOffset ? topOffset : 0)
  return (
        el.contains(efp(rect_left,  rect_top))
    ||  el.contains(efp(rect.right, rect_top))
    ||  el.contains(efp(rect.right, rect.bottom))
    ||  el.contains(efp(rect_left,  rect.bottom))
  );
}

async function open_wave_editor(wave_name) {
  let el = g_wave_open_editors[wave_name]
  if ( el !== undefined ) {
    let container = g_wave_open_editors[wave_name].display
    if ( !isElementVisible(container,20,20) ) {
      container.style.top = "20px"
      container.style.left = "20px"
    }
    switch_z(container)
    return
  }
  let div = document.getElementById('wave-graph-tmplt')
  let clone = div.cloneNode(true); // true means clone all childNodes and all event handlers
  clone.id = wave_name;
  document.body.appendChild(clone);
  clone.style.display = 'block'
  clone.style.display = 'visible'
  clone._app_dragging = false
  if ( div._app_zIndex === undefined ) div._app_zIndex = 500
  else  div._app_zIndex++
  clone.style.zIndex = div._app_zIndex
  clone._app_zIndex = div._app_zIndex
  console.log(clone.style.zIndex)
  //
  let canvas = clone.getElementsByTagName('canvas')[0];
  //
  const dpr = window.devicePixelRatio || 1;
  const padding = 20;
  canvas.width = canvas.offsetWidth * dpr;
  canvas.height = (canvas.offsetHeight + padding * 2) * dpr;
  const ctx = canvas.getContext("2d");
  ctx.scale(dpr, dpr);
  ctx.translate(0, canvas.offsetHeight / 2 + padding); // Set Y = 0 to be in the middle of the canvas
  //
  let audio_el = document.getElementById(`audio-player-${wave_name}`)
  if ( audio_el ) {
    audio_el.ontimeupdate = (event) => {
      let aud_el = event.target
      if ( aud_el ) {
        let play_info = g_wave_open_editors[wave_name]
        if ( play_info ) {
          let play_time = aud_el.currentTime
          let duration = aud_el.duration
          let percent = play_time/duration
          let ctx = play_info.graph
          let prev_offset = play_info.where_ticker
          update_play_marker(ctx,play_info,percent)
        }
      }
    }
  }
  //
  g_wave_open_editors[wave_name] = { 
    'display' : clone, 
    'canvas' : canvas, 
    'graph' : ctx, 
    'player' : audio_el, 
    'where_ticker' : 0, 
    'width' : canvas.offsetWidth,
    'height' : canvas.height,
    'selection_rect' : {},
    'save_selection' : {},
    'ops_undo_stack' : [],
    'dragging' : false
  }
  //
  let data = await get_wave_data(wave_name)
  let W = canvas.offsetWidth
  let h = canvas.height
  let rec_seconds = get_wave_seconds(wave_name)
  //
  draw_wave(data,ctx,W,h,rec_seconds) 
  //
  // Editor Drawing Events
  let player_info = g_wave_open_editors[wave_name]
  let wv_edit_mouseDown = (e) => {
    //
    wv_clear_selection(player_info)
    //
    player_info.selection_rect = {}
    let container = player_info.display
    player_info.selection_rect.startX = e.pageX - container.offsetLeft;
    player_info.selection_rect.startY = -player_info.height //e.pageY - canvas.offsetTop;
    player_info.selection_rect.h = (2*player_info.height)
    player_info.selection_rect.w = 0
    player_info.dragging = true;
  }
  let wv_edit_mouseUp = (e) => { player_info.dragging = false }
  let wv_edit_mouseMove = (e) => {
    if ( player_info.dragging ) {
      let canvas = player_info.canvas
      let saved_comp = ctx.globalCompositeOperation
      let rect = player_info.selection_rect
      ctx.globalCompositeOperation = 'xor'
      ctx.fillStyle = "#000000";
      ctx.fillRect(rect.startX, rect.startY, rect.w, rect.h);
      let container = player_info.display
      rect.w = (e.pageX - container.offsetLeft) - rect.startX;
      ctx.fillRect(rect.startX, rect.startY, rect.w, rect.h);
      ctx.globalCompositeOperation = saved_comp
      player_info.save_selection.startX = rect.startX
      player_info.save_selection.startY = rect.startY
      player_info.save_selection.w = rect.w
      player_info.save_selection.h = rect.h
    }
  }
  canvas.addEventListener('mousedown', wv_edit_mouseDown, false);
  canvas.addEventListener('mouseup', wv_edit_mouseUp, false);
  canvas.addEventListener('mousemove', wv_edit_mouseMove, false);
}



//  g_wave_open_editors[wave_name] = { 'display' : clone, 'graph' : ctx }
//
//
function remove_wave_editor(wave_name) {
  let editor_data = g_wave_open_editors[wave_name]
  if ( editor_data ) {
    let container = editor_data.display
    find_new_z(wave_name,container,g_wave_open_editors)
    if ( container ) container.remove()
    delete  g_wave_open_editors[wave_name]
  }
}
//
function wv_closer_editor(e) {
  e = e || window.event;
  e.preventDefault();

  let t = e.target
  if ( t ) {
    try {
      g_wave_current_container = null
      let container = t.parentNode.parentNode
      let wave_name = container.id
      remove_wave_editor(wave_name)
    } catch(e) {
    }
  }
}

// //
// //
function wv_zoom_in(ev) {
  ev = ev || window.event;
  ev.preventDefault();
  let the_button = ev.target
  let container = the_button.parentNode.parentNode
  if ( container ) {

  }
}

function wv_scroll_left(ev) {
  ev = ev || window.event;
  ev.preventDefault();
  let the_button = ev.target
  let container = the_button.parentNode.parentNode
  if ( container ) {

  }
}

function wv_scroll_right(ev) {
  ev = ev || window.event;
  ev.preventDefault();
  let the_button = ev.target
  let container = the_button.parentNode.parentNode
  if ( container ) {
    
  }
}

//  wv_cut_data
function wv_cut_data(data,selection_rect,samples_per_pixel) {
  let start = (selection_rect.startX)*samples_per_pixel
  let end = (selection_rect.w)*samples_per_pixel + start
  let tail_data = data.subarray(end)
  data.set(tail_data,start)
  let display_data = data.slice(0,(start + tail_data.length))
  return(display_data)
}

async function wv_cut_selection(ev) {
  ev = ev || window.event;
  ev.preventDefault();
  let the_button = ev.target
  let container = the_button.parentNode.parentNode.parentNode
  if ( container ) {
    let wave_name = container.id
    let player_info = g_wave_open_editors[wave_name]
    //
    let canvas = player_info.canvas
    if ( canvas && (player_info.save_selection.startX !== undefined) ) {
      if ( player_info.save_selection.w <= 0 ) {   // turn the selection around only when it is backwards
        if ( player_info.save_selection.w === 0 ) return
        else {
          let w = player_info.save_selection.w
          let sx = player_info.save_selection.startX + w
          player_info.save_selection.w = -w
          player_info.save_selection.startX = sx
        }
      }
      //
      let data_list = await get_wave_data(wave_name,2)
      player_info.ops_undo_stack.push({ 'op' : 'cut',
                                              'data' : new Float32Array(data_list[0]), 
                                              'data2' : new Float32Array(data_list[1]) })
      let W = canvas.offsetWidth
      let h = canvas.height
      let n_pixels = (W - ZERO_AXIS_OFFSET)
      let samples_per_pixel = Math.ceil(data_list[0].length/n_pixels)
      let display_data = wv_cut_data(data_list[0],player_info.save_selection,samples_per_pixel)
      let c2_data = null
      if ( data_list.length > 1 ) {
        c2_data = wv_cut_data(data_list[1],player_info.save_selection,samples_per_pixel)
      } else {
        c2_data = new Float32Array(display_data)
      }
      //
      wv_clear_selection(player_info)
      let ctx = player_info.graph
      let sample_rate = g_audioContext.sampleRate
      let rec_seconds = (1.0*display_data.length)/sample_rate
      draw_wave(display_data,ctx,W,h,rec_seconds)
      //
      data_list = [display_data,c2_data]
      player_info.save_selection.samplePP = samples_per_pixel
      update_audio_data(wave_name,data_list,player_info.save_selection)
    }
  }
}








function wv_restore_selection(ev) {
  ev = ev || window.event;
  ev.preventDefault();
  let the_button = ev.target
  let container = the_button.parentNode.parentNode.parentNode
  if ( container ) {
    let wave_name = container.id
    let player_info = g_wave_open_editors[wave_name]
    // // //
    if (  player_info.ops_undo_stack.length ) {
      let undo_op = player_info.ops_undo_stack.pop()
      let data = null
      if ( undo_op.op === 'cut' ) {
        let canvas = player_info.canvas
        if ( canvas ) {
          data = undo_op.data
          //
          let W = canvas.offsetWidth
          let h = canvas.height
          let ctx = player_info.graph
          let sample_rate = g_audioContext.sampleRate
          let rec_seconds = (1.0*data.length)/sample_rate
          draw_wave(data,ctx,W,h,rec_seconds)
          //
          let data2 = undo_op.data2
          let data_list = [data,data2]
          update_audio_data(wave_name,data_list,false)
        }
      }
    }
  }
}
// // //

function switch_z(container,prev_c) {
  let source_c = ( prev_c === undefined ) ? g_wave_current_container : prev_c
  //
  if ( source_c !== null ) {
    if ( container.className == 'wave-graph-container' ) {
      if ( container !== source_c ) {
        let z = container._app_zIndex
        if ( z !== undefined ) {
          container._app_zIndex = source_c._app_zIndex
          container.style.zIndex = source_c._app_zIndex
          source_c.style.zIndex = z
          source_c._app_zIndex = z
        }
      }
    }
  }
}

function find_new_z(wave_name,container,open_containers) {
  let c_names = Object.keys(open_containers)
  if ( c_names.length > 1 ) {
    let n = c_names.length
    let max_z = -1
    let switcher = null
    for ( let i = 0; i < n; i++ ) {
      let name = c_names[i]
      if ( name !== wave_name ) {
        let oc = open_containers[name].display
        let z = oc._app_zIndex
        if ( z > max_z ) {
          max_z = z
          switcher = oc
        }
      }
    }
    if ( switcher ) {
      switch_z(switcher,container)
      g_wave_current_container = switcher
    }
  }
}

//
function wv_capture_cursor(ev,el_depth)  {
  ev = ev || window.event;
  //ev.preventDefault();

  let controlBar = ev.target
  if ( controlBar ) {
    let container = controlBar.parentNode
    if ( el_depth ) container = container.parentNode
    if ( container ) {
      switch_z(container)
      let x = ev.clientX;
      let y = ev.clientY; 
      container._app_mouse_x = x
      container._app_mouse_y = y
      container._app_dragging = true
      if ( container.className == 'wave-graph-container' ) {
        g_wave_current_container = container
        document.addEventListener('mouseup',(ev) => {
          if ( g_wave_current_container != null ) {
            g_wave_current_container._app_dragging = false
          }
        })
      }
    }
  }
}
//
function wv_release_captured_cursor(ev,check_limits,el_depth) {
  ev = ev || window.event;
  if ( !check_limits ) ev.preventDefault();
  //
  let controlBar = ev.target
  if ( controlBar ) {
    let container = controlBar.parentNode
    if ( el_depth ) container = container.parentNode
    if ( container ) {
      if ( check_limits ) {
        let check_y = Math.abs(container.offsetTop - ev.clientY)
        let check_x = Math.abs(container._app_mouse_x - ev.clientX)
        let dist = Math.sqrt((0.25)*check_y*check_y + check_x*check_x)
        if ( dist < WV_CONST_MOUSE_DRAG_DIST_TOLERANCE ) return
      }
      container._app_dragging = false
    }
  }
}
//
function wv_check_cursor_entry(ev,el_depth) {
  ev = ev || window.event;
  ev.preventDefault();
  let controlBar = ev.target
  if ( controlBar ) {
    let container = controlBar.parentNode
    if ( el_depth ) container = container.parentNode
    if ( container ) {
      if ( ev.buttons === 0 ) {
        container._app_dragging = false
      }
    }
  }
}
//
function wv_track_cursor_out(ev,el_depth) {
  ev = ev || window.event;
  ev.preventDefault();
  //
  let controlBar = ev.target
  if ( controlBar ) {
    let container = controlBar.parentNode
    if ( el_depth ) container = container.parentNode
    if ( container && container._app_dragging ) {
      // calculate the new cursor position:
      let prev_x = container._app_mouse_x - ev.clientX;
      let prev_y = container._app_mouse_y - ev.clientY;
      container._app_mouse_x = ev.clientX;
      container._app_mouse_y = ev.clientY;
      // set the element's new position:
      let new_y = (container.offsetTop - prev_y)
      let new_x = (container.offsetLeft - prev_x)
      if ( new_y > 8 ) container.style.top = new_y + "px";
      if ( new_x > 8 ) container.style.left = new_x + "px";
    }
  }
}
//
function wv_track_cursor(ev,el_depth) {
  ev = ev || window.event;
  ev.preventDefault();
  //
  let controlBar = ev.target
  if ( controlBar ) {
    let container = controlBar.parentNode
    if ( el_depth ) container = container.parentNode
    if ( container && container._app_dragging ) {
      // calculate the new cursor position:
      let prev_x = container._app_mouse_x - ev.clientX;
      let prev_y = container._app_mouse_y - ev.clientY;
      container._app_mouse_x = ev.clientX;
      container._app_mouse_y = ev.clientY;
      // set the element's new position:
      let new_y = (container.offsetTop - prev_y)
      let new_x = (container.offsetLeft - prev_x)
      if ( new_y > 8 ) container.style.top = new_y + "px";
      if ( new_x > 8 ) container.style.left = new_x + "px";
    }
  }
}
//
function wv_edit_checked() {
  var checkedBoxes = document.querySelectorAll('input[name=audioSections]:checked');
  checkedBoxes.forEach(cbox => {
    let wave_name = cbox.id.replace('audio-cbox-','')
    open_wave_editor(wave_name)
  })
}
// 
function wv_delete_checked() {
  var checkedBoxes = document.querySelectorAll('input[name=audioSections]:checked');
  checkedBoxes.forEach(cbox => {
    let cbox_id = cbox.id
    let container_id = cbox_id.replace('cbox','div')
    let container = document.getElementById(container_id)
    if ( container ) {
      let parent = savedAudioMessagesContainer //container.parentNode()
      parent.removeChild(container)
      remove_audio_data(cbox_id.replace('audio-cbox-',''))
    }
  })
}

// ---- ---- ---- ---- ---- ----


// ------ ------ ------ ------ ------ ------ ------ ------ ------ ------ ------ ------ ------ ------ ------ ------
// ------ ------ ------ ------ ------ ------ ------ ------ ------ ------ ------ ------ ------ ------ ------ ------
// UPLOAD AND DOWNLOAD

// DATA TO AND FROM USER DISK

//  download_audio_session_record
//  -- present a dialog to a user for downloading the current session in some audio format that deterines ext
var downloader_url = null
async function download_audio_session_record(sess_name,downloadlink) {
  if ( !(downloadlink) ) return false
  let sess_name_cmplt = sess_name + '-complete'
  let data = await get_audio_key(sess_name_cmplt)
  if ( data ) {
    //
    let sess_blob = data.blob
    let barray = convertDataURIToBinary(sess_blob)
    //
    //let snd = new Audio(sess_blob)
    //snd.play()

    // //
    let contentType = g_preferred_download_format
    let file_data = new Blob([barray], {type: contentType});
    //
    //
    let f_url = URL.createObjectURL(file_data);

    if ( downloader_url !== null ) {
      URL.revokeObjectURL(downloader_url)
    }
    downloader_url = f_url
    downloadlink.href = f_url
    let ext = data.ext ? data.ext : "mp3"
    downloadlink.download = sess_name + '.' + ext;
    downloadlink.click();
    //
    return true
  }
  return false
}



// // 
async function download_prompt() {
  let downloader = g_audio_download_modal
  let downloadlink = document.getElementById('wave-download-link')
  if ( downloader && downloadlink ) {
    downloadlink.innerHTML = `Download ${g_current_session_name}`
    if ( downloader.showModal ) downloader.showModal()
    else {
      downloader.style.visibility = 'visible'
      downloader.style.display = 'block'
    }
    let result = await download_audio_session_record(g_current_session_name,downloadlink)
    if ( result ) {
      // maybe send a copy to the server ???
    }
    if ( downloader.close ) downloader.close()
    else {
      downloader.style.visibility = 'hidden'
      downloader.style.display = 'none'
    }
  }
}


/// ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----

function handle_session_upload(ev) {
  //
}

function worker_status_view(status) {
  //
}

function worker_op_response(data) {
  //
}

// ---- ---- ---- ---- ---- ----

// ---- ---- ---- ---- ---- ----
// ---- ---- ---- ---- ---- ----

function wv_getLocation() {
  if (navigator.geolocation) {
    var x = document.getElementById("wv-geo-location");
    navigator.geolocation.watchPosition((position) => {  // watch position updates location at a system defined interval
      x.innerHTML = `${position.coords.latitude},${position.coords.longitude}`
      g_wv_current_locaion = { "latitude" : position.coords.latitude, "longitude" : position.coords.longitude }  // clone
      wv_update_geo_location(g_wv_current_locaion)
    });
  } else { 
    alert("Geolocation is not supported by this browser.");
  }
}




// ---- ---- ---- ---- ---- ----
// ---- ---- ---- ---- ---- ----


function stop_geo_update() {
  if ( g_geo_update ) clearInterval(g_geo_update)
}

function restart_geo_update() {
  if ( g_geo_update ) clearInterval(g_geo_update)
  //g_geo_update = setInterval(wv_getLocation,GEO_UPDATE_INTERVAL)
}

// ---- ---- ---- ---- ---- ----
async function initialize_data_operations() {
  g_audio_db = await wv_init_database()
}



async function application_initialization() {
  //
  wv_getLocation()
  wv_init_recorder()
  wv_initialize_global_buttons()
  //
  await initialize_data_operations()
  await wv_default_session_readiness()
}


// ---- ----

function show_recorder(event) {
  let rec_el_nm = "big-recorder"
  let mng_el_nm = "record-manager"
  let rec_el = document.getElementById(rec_el_nm)
  let mng_el = document.getElementById(mng_el_nm)
  if ( rec_el && mng_el ) {
    rec_el.style.display= "block"
    mng_el.style.display = "none"
    //
    let stylish_guy = document.getElementById("btn-pick_recorder")
    stylish_guy.style.border = "2px solid navy"
    stylish_guy.style.borderRadius = "4px"
    //
    let plain_guy = document.getElementById("btn-pick_manager")
    plain_guy.style.border = "1px solid black"
    plain_guy.style.borderRadius = "4px"
  }
}

function show_manager(event) {
  let rec_el_nm = "big-recorder"
  let mng_el_nm = "record-manager"
  let rec_el = document.getElementById(rec_el_nm)
  let mng_el = document.getElementById(mng_el_nm)
  if ( rec_el && mng_el ) {
    rec_el.style.display= "none"
    mng_el.style.display = "block"
    //
    let stylish_guy = document.getElementById("btn-pick_manager")
    stylish_guy.style.border = "2px solid navy"
    stylish_guy.style.borderRadius = "4px"
    //
    let plain_guy = document.getElementById("btn-pick_recorder")
    plain_guy.style.border = "1px solid black"
    plain_guy.style.borderRadius = "4px"
  }
}


// async wrapper 
async function first_initializer() {
  await application_initialization()
}
//
first_initializer()
show_recorder(event)
/*
*/






/*

// this.mediaRecorder.start(this.chunk_interval);    /// allows data available to run


const chunks = [];

mediaRecorder.onstop = (e) => {
  console.log("data available after MediaRecorder.stop() called.");

  const audio = document.createElement("audio");
  audio.controls = true;
  const blob = new Blob(chunks, { type: mediaRecorder.mimeType });
  const audioURL = window.URL.createObjectURL(blob);
  audio.src = audioURL;
  console.log("recorder stopped");
};

mediaRecorder.ondataavailable = (e) => {
  chunks.push(e.data);
};




let arbuf = blob.arrayBuffer()    // everywhere

//Blob.arrayBuffer()


// Blob.bytes() ... only Mozilla

*/
</script>




